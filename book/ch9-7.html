---
layout: master
title: Pro Git 9.7 Git Internals Git References
---
<h2 id='git_references'>Git References</h2>

<p>So now we can run something like <code>git log 1a410e</code> to look through our whole history, but we still would have to remember that <code>1a410e</code> was the last commit in order to walk that history to find all those objects. What we need is a file where we can store that SHA-1 value under a simple name so we can use that pointer rather than the raw SHA-1 value itself.</p>

<p>In Git, these are called &#8216;references&#8217; or &#8216;refs&#8217; and you can find the files that contain the SHA-1 values in the &#8216;.git/refs&#8217; directory. In our current project, this directory contains no files, but it does contain a simple structure.</p>

<pre><code>$ find .git/refs
.git/refs
.git/refs/heads
.git/refs/tags
$ find .git/refs -type f
$</code></pre>

<p>If we want to create a new reference to remember where our latest commit is, we can technically do something as simple as this:</p>

<pre><code>$ echo &quot;1a410efbd13591db07496601ebc7a059dd55cfe9&quot; &gt; .git/refs/heads/master</code></pre>

<p>Now we can use the head reference we just created instead of the SHA-1 value in our Git commands.</p>

<pre><code>$ git log --pretty=oneline  master
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>

<p>It is not encouraged to actually directly edit the reference files, Git provides a safer command to do this if you want to update a reference called &#8216;update-ref&#8217;.</p>

<pre><code>$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>

<p>So that&#8217;s basically what a branch in Git is, a simple pointer - a reference to the head of a line of work. If we wanted to create a branch back at the second commit, we could do this:</p>

<pre><code>$ git update-ref refs/heads/test cac0ca</code></pre>

<p>Then our branch will only contain work from that commit down.</p>

<pre><code>$ git log --pretty=oneline test
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>

<p>Now our Git database conceptually looks something like Figure 9.4.</p>

<p>Fig4</p>

<p>DWP: I notice the hashes for the three commits are all the same in the diagram. That can&#8217;t be right, can it? Ditto the figure 3.</p>

<p>DWP: Need a link to the diagram here too.</p>

<p>When you run commands like <code>git branch (branchname)</code> what Git is basically doing is running that <code>update-ref</code> command to add the SHA-1 of the last commit of the branch you are on into whatever new reference you want to create.</p>

<h3 id='the_head'>The HEAD</h3>

<p>The question now is, when I run <code>git branch (branchname)</code>, how does Git know what the SHA-1 of the last commit is? The answer is the HEAD file. The HEAD file is a symbolic reference to the branch you are currently on. By &#8216;symbolic reference&#8217; I mean that unlike a normal reference, it does not generally contain a SHA-1 value, but instead a pointer to another reference. If we look at the file itself, we will normally see something like this:</p>

<pre><code>$ cat .git/HEAD 
ref: refs/heads/master</code></pre>

<p>If you run <code>git checkout test</code>, Git will update this file to look like this:</p>

<pre><code>$ cat .git/HEAD 
ref: refs/heads/test</code></pre>

<p>When you run <code>git commit</code>, it will create the commit object specifying the parent of that commit object to be whatever SHA-1 value the reference in HEAD points to.</p>

<p>sop: Should we mention here that <code>git symbolic-ref</code> is a better way to read/edit this file, just like <code>git update-ref</code> is a better way to edit a ref file?</p>

<h3 id='tags'>Tags</h3>

<p>We&#8217;ve just gone over the three main object types in Git, but there is actually a fourth one. The &#8216;tag&#8217; object is very much like a commit object - it contains a tagger, a date, a message and a pointer. The main difference is that a tag object points to a commit rather than a tree. It is like a branch reference but it never moves - it always points to the same commit, just giving it a more friendly name.</p>

<p>As we cover in Chapter 2, there are two types of tags - annotated and lightweight. A lightweight tag can basically be made by running something like this:</p>

<pre><code>$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d</code></pre>

<p>That is all a lightweight tag is - a branch that never moves. An annotated tag is more complex, however. If we create an annotated tag, Git will create a &#8216;tag&#8217; object and then write a reference to point to <em>that</em>, rather than directly to the commit. We can see this by creating an annotated tag</p>

<pre><code>$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>

<p>DWP: Where -a means add it rather than just show it?</p>

<p>Then seeing what the object SHA-1 value it created is</p>

<pre><code>$ cat .git/refs/tags/v1.1 
9585191f37f7b0fb9444f35a9bf50de191beadc2</code></pre>

<p>Then we can run the <code>cat-file</code> command on that SHA-1 value.</p>

<pre><code>$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700

test tag</code></pre>

<p>DWP: I&#8217;m confused. How did the text &#8216;test tag&#8217; get in here?</p>

<p>Notice that the &#8216;object&#8217; entry points to the commit SHA-1 value that we tagged. Also notice that it doesn&#8217;t even need to point to a commit, you can tag any Git object. In the Git source code, for example, the maintainer has added his GPG public key as a blob object and then tagged it. You can view the public key by running:</p>

<pre><code>$ git cat-file blob junio-gpg-pub</code></pre>

<p>in the Git source code. The Linux kernel also has a non-commit pointing tag object - the very first tag created points to the initial tree of the import of the source code.</p>

<h3 id='remotes'>Remotes</h3>

<p>The third type of reference that you will see are remote references. If you add a remote and push to it, Git will store what value you last pushed to that remote for each branch in the &#8216;refs/remotes&#8217; directory. For instance, if I add a remote called &#8216;origin&#8217; and push my &#8216;master&#8217; branch to it:</p>

<pre><code>$ git remote add origin git@github.com:schacon/simplegit-progit.git
$ git push origin master
Counting objects: 11, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (7/7), 716 bytes, done.
Total 7 (delta 2), reused 4 (delta 1)
To git@github.com:schacon/simplegit-progit.git
   a11bef0..ca82a6d  master -&gt; master</code></pre>

<p>Then I can see what the &#8216;master&#8217; branch on the &#8216;origin&#8217; remote was the last time I communicated with the server by checking the &#8216;refs/remotes/origin/master&#8217; file:</p>

<pre><code>$ cat .git/refs/remotes/origin/master 
ca82a6dff817ec66f44342007202690a93763949</code></pre>

<p>Remote references differ from branches (refs/heads references) mainly in that they cannot be checked out. Git simply moves them around as bookmarks to the last known state of where those branches were on those servers.</p>

<p>DWP: It feels like there ought to be slightly more on remotes here. For all the other things you&#8217;ve shown exactly what is stored in the file. Where and how does git store the remote url?</p>

<div id='nav'>
<a href='ch9-6.html'>prev</a> | <a href='ch9-8.html'>next</a>
</div>