---
layout: translation
title: Pro Git 5.2 分布式 Git 为项目作贡献
---
<h2 id='id260'>为项目作贡献</h2>

<p>接下来，我们来学习一下作为项目贡献者，会有哪些常见的工作模式。</p>

<p>不过要说清楚整个协作过程真的很难，Git 如此灵活，人们的协作方式便可以各式各样，没有固定不变的范式可循，而每个项目的具体情况又多少会有些不同，比如说参与者的规模，所选择的工作流程，每个人的提交权限，以及 Git 以外贡献等等，都会影响到具体操作的细节。</p>

<p>首当其冲的是参与者规模。项目中有多少开发者是经常提交代码的？经常又是多久呢？大多数两至三人的小团队，一天大约只有几次提交，如果不是什么热门项目的话就更少了。可要是在大公司里，或者大项目中，参与者可以多到上千，每天都会有十几个上百个补丁提交上来。这种差异带来的影响是显著的，越是多的人参与进来，就越难保证每次合并正确无误。你正在工作的代码，可能会因为合并进来其他人的更新而变得过时，甚至受创无法运行。而已经提交上去的更新，也可能在等着审核合并的过程中变得过时。那么，我们该怎样做才能确保代码是最新的，提交的补丁也是可用的呢？</p>

<p>接下来便是项目所采用的工作流。是集中式的，每个开发者都具有等同的写权限？项目是否有专人负责检查所有补丁？是不是所有补丁都做过同行复阅（peer-review）再通过审核的？你是否参与审核过程？如果使用副官系统，那你是不是限定于只能向此副官提交？</p>

<p>还有你的提交权限。有或没有向主项目提交更新的权限，结果完全不同，直接决定最终采用怎样的工作流。如果不能直接提交更新，那该如何贡献自己的代码呢？是不是该有个什么策略？你每次贡献代码会有多少量？提交频率呢？</p>

<p>所有以上这些问题都会或多或少影响到最终采用的工作流。接下来，我会在一系列由简入繁的具体用例中，逐一阐述。此后在实践时，应该可以借鉴这里的例子，略作调整，以满足实际需要构建自己的工作流。</p>

<h3 id='id261'>提交指南</h3>

<p>开始分析特定用例之前，先来了解下如何撰写提交说明。一份好的提交指南可以帮助协作者更轻松更有效地配合。Git 项目本身就提供了一份文档（Git 项目源代码目录中 <code>Documentation/SubmittingPatches</code>），列数了大量提示，从如何编撰提交说明到提交补丁，不一而足。</p>

<p>首先，请不要在更新中提交多余的白字符（whitespace）。Git 有种检查此类问题的方法，在提交之前，先运行 <code>git diff --check</code>，会把可能的多余白字符修正列出来。下面的示例，我已经把终端中显示为红色的白字符用 <code>X</code> 替换掉：</p>

<pre><code>$ git diff --check
lib/simplegit.rb:5: trailing whitespace.
+    @git_dir = File.expand_path(git_dir)XX
lib/simplegit.rb:7: trailing whitespace.
+ XXXXXXXXXXX
lib/simplegit.rb:26: trailing whitespace.
+    def command(git_cmd)XXXX</code></pre>

<p>这样在提交之前你就可以看到这类问题，及时解决以免困扰其他开发者。</p>

<p>接下来，请将每次提交限定于完成一次逻辑功能。并且可能的话，适当地分解为多次小更新，以便每次小型提交都更易于理解。请不要在周末穷追猛打一次性解决五个问题，而最后拖到周一再提交。就算是这样也请尽可能利用暂存区域，将之前的改动分解为每次修复一个问题，再分别提交和加注说明。如果针对两个问题改动的是同一个文件，可以试试看 <code>git add --patch</code> 的方式将部分内容置入暂存区域（我们会在第六章再详细介绍）。无论是五次小提交还是混杂在一起的大提交，最终分支末端的项目快照应该还是一样的，但分解开来之后，更便于其他开发者复阅。这么做也方便自己将来取消某个特定问题的修复。我们将在第六章介绍一些重写提交历史，同暂存区域交互的技巧和工具，以便最终得到一个干净有意义，且易于理解的提交历史。</p>

<p>最后需要谨记的是提交说明的撰写。写得好可以让大家协作起来更轻松。一般来说，提交说明最好限制在一行以内，50 个字符以下，简明扼要地描述更新内容，空开一行后，再展开详细注解。Git 项目本身需要开发者撰写详尽注解，包括本次修订的因由，以及前后不同实现之间的比较，我们也该借鉴这种做法。另外，提交说明应该用祈使现在式语态，比如，不要说成 “I added tests for” 或 “Adding tests for” 而应该用 “Add tests for”。下面是来自 tpope.net 的 Tim Pope 原创的提交说明格式模版，供参考：</p>

<pre><code>本次更新的简要描述（50 个字符以内）

如果必要，此处展开详尽阐述。段落宽度限定在 72 个字符以内。
某些情况下，第一行的简要描述将用作邮件标题，其余部分作为邮件正文。
其间的空行是必要的，以区分两者（当然没有正文另当别论）。
如果并在一起，rebase 这样的工具就可能会迷惑。

另起空行后，再进一步补充其他说明。

 - 可以使用这样的条目列举式。

 - 一般以单个空格紧跟短划线或者星号作为每项条目的起始符。每个条目间用一空行隔开。
   不过这里按自己项目的约定，可以略作变化。</code></pre>

<p>如果你的提交说明都用这样的格式来书写，好多事情就可以变得十分简单。Git 项目本身就是这样要求的，我强烈建议你到 Git 项目仓库下运行 <code>git log --no-merges</code> 看看，所有提交历史的说明是怎样撰写的。（译注：如果现在还没有克隆 git 项目源代码，是时候 <code>git clone git://git.kernel.org/pub/scm/git/git.git</code> 了。）</p>

<p>为简单起见，在接下来的例子（及本书随后的所有演示）中，我都不会用这种格式，而使用 <code>-m</code> 选项提交 <code>git commit</code>。不过请还是按照我之前讲的做，别学我这里偷懒的方式。</p>

<h3 id='id262'>私有的小型团队</h3>

<p>我们从最简单的情况开始，一个私有项目，与你一起协作的还有另外一到两位开发者。这里说私有，是指源代码不公开，其他人无法访问项目仓库。而你和其他开发者则都具有推送数据到仓库的权限。</p>

<p>这种情况下，你们可以用 Subversion 或其他集中式版本控制系统类似的工作流来协作。你仍然可以得到 Git 带来的其他好处：离线提交，快速分支与合并等等，但工作流程还是差不多的。主要区别在于，合并操作发生在客户端而非服务器上。让我们来看看，两个开发者一起使用同一个共享仓库，会发生些什么。第一个人，John，克隆了仓库，作了些更新，在本地提交。（下面的例子中省略了常规提示，用 <code>...</code> 代替以节约版面。）</p>

<pre><code># John&#39;s Machine
$ git clone john@githost:simplegit.git
Initialized empty Git repository in /home/john/simplegit/.git/
...
$ cd simplegit/
$ vim lib/simplegit.rb 
$ git commit -am &#39;removed invalid default value&#39;
[master 738ee87] removed invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>

<p>第二个开发者，Jessica，一样这么做：克隆仓库，提交更新：</p>

<pre><code># Jessica&#39;s Machine
$ git clone jessica@githost:simplegit.git
Initialized empty Git repository in /home/jessica/simplegit/.git/
...
$ cd simplegit/
$ vim TODO 
$ git commit -am &#39;add reset task&#39;
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre>

<p>现在，Jessica 将她的工作推送到服务器上：</p>

<pre><code># Jessica&#39;s Machine
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -&gt; master</code></pre>

<p>John 也尝试推送自己的工作上去：</p>

<pre><code># John&#39;s Machine
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -&gt; master (non-fast forward)
error: failed to push some refs to &#39;john@githost:simplegit.git&#39;</code></pre>

<p>John 的推送操作被驳回，因为 Jessica 已经推送了新的数据上去。请注意，特别是你用惯了 Subversion 的话，这里其实修改的是两个文件，而不是同一个文件的同一个地方。Subversion 会在服务器端自动合并提交上来的更新，而 Git 则必须先在本地合并后才能推送。于是，John 不得不先把 Jessica 的更新拉下来：</p>

<pre><code>$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -&gt; origin/master</code></pre>

<p>此刻，John 的本地仓库如图 5-4 所示：</p>

<p><center><img src="/figures/ch5/18333fig0504-tn.png"></center><br/> 图 5-4. John 的仓库历史</p>

<p>虽然 John 下载了 Jessica 推送到服务器的最近更新（fbff5），但目前只是 <code>origin/master</code> 指针指向它，而当前的本地分支 <code>master</code> 仍然指向自己的更新（738ee），所以需要先把她的提交合并过来，才能继续推送数据：</p>

<pre><code>$ git merge origin/master
Merge made by recursive.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre>

<p>还好，合并过程非常顺利，没有冲突，现在 John 的提交历史如图 5-5 所示：</p>

<p><center><img src="/figures/ch5/18333fig0505-tn.png"></center><br/> 图 5-5. 合并 origin/master 后 John 的仓库历史</p>

<p>现在，John 应该再测试一下代码是否仍然正常工作，然后将合并结果（72bbc）推送到服务器上：</p>

<pre><code>$ git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -&gt; master</code></pre>

<p>最终，John 的提交历史变为图 5-6 所示：</p>

<p><center><img src="/figures/ch5/18333fig0506-tn.png"></center><br/> 图 5-6. 推送后 John 的仓库历史</p>

<p>而在这段时间，Jessica 已经开始在另一个特性分支工作了。她创建了 <code>issue54</code> 并提交了三次更新。她还没有下载 John 提交的合并结果，所以提交历史如图 5-7 所示：</p>

<p><center><img src="/figures/ch5/18333fig0507-tn.png"></center><br/> 图 5-7. Jessica 的提交历史</p>

<p>Jessica 想要先和服务器上的数据同步，所以先下载数据：</p>

<pre><code># Jessica&#39;s Machine
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -&gt; origin/master</code></pre>

<p>于是 Jessica 的本地仓库历史多出了 John 的两次提交（738ee 和 72bbc），如图 5-8 所示：</p>

<p><center><img src="/figures/ch5/18333fig0508-tn.png"></center><br/> 图 5-8. 获取 John 的更新之后 Jessica 的提交历史</p>

<p>此时，Jessica 在特性分支上的工作已经完成，但她想在推送数据之前，先确认下要并进来的数据究竟是什么，于是运行 <code>git log</code> 查看：</p>

<pre><code>$ git log --no-merges origin/master ^issue54
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 16:01:27 2009 -0700

    removed invalid default value</code></pre>

<p>现在，Jessica 可以将特性分支上的工作并到 <code>master</code> 分支，然后再并入 John 的工作（<code>origin/master</code>）到自己的 <code>master</code> 分支，最后再推送回服务器。当然，得先切回主分支才能集成所有数据：</p>

<pre><code>$ git checkout master
Switched to branch &quot;master&quot;
Your branch is behind &#39;origin/master&#39; by 2 commits, and can be fast-forwarded.</code></pre>

<p>要合并 <code>origin/master</code> 或 <code>issue54</code> 分支，谁先谁后都没有关系，因为它们都在上游（upstream）（译注：想像分叉的更新像是汇流成河的源头，所以上游 upstream 是指最新的提交），所以无所谓先后顺序，最终合并后的内容快照都是一样的，而仅是提交历史看起来会有些先后差别。Jessica 选择先合并 <code>issue54</code>：</p>

<pre><code>$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)</code></pre>

<p>正如所见，没有冲突发生，仅是一次简单快进。现在 Jessica 开始合并 John 的工作（<code>origin/master</code>）：</p>

<pre><code>$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>

<p>所有的合并都非常干净。现在 Jessica 的提交历史如图 5-9 所示：</p>

<p><center><img src="/figures/ch5/18333fig0509-tn.png"></center><br/> 图 5-9. 合并 John 的更新后 Jessica 的提交历史</p>

<p>现在 Jessica 已经可以在自己的 <code>master</code> 分支中访问 <code>origin/master</code> 的最新改动了，所以她应该可以成功推送最后的合并结果到服务器上（假设 John 此时没再推送新数据上来）：</p>

<pre><code>$ git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -&gt; master</code></pre>

<p>至此，每个开发者都提交了若干次，且成功合并了对方的工作成果，最新的提交历史如图 5-10 所示：</p>

<p><center><img src="/figures/ch5/18333fig0510-tn.png"></center><br/> 图 5-10. Jessica 推送数据后的提交历史</p>

<p>以上就是最简单的协作方式之一：先在自己的特性分支中工作一段时间，完成后合并到自己的 <code>master</code> 分支；然后下载合并 <code>origin/master</code> 上的更新（如果有的话），再推回远程服务器。一般的协作流程如图 5-11 所示：</p>

<p><center><img src="/figures/ch5/18333fig0511-tn.png"></center><br/> 图 5-11. 多用户共享仓库协作方式的一般工作流程时序</p>

<h3 id='id263'>私有团队间协作</h3>

<p>现在我们来看更大一点规模的私有团队协作。如果有几个小组分头负责若干特性的开发和集成，那他们之间的协作过程是怎样的。</p>

<p>假设 John 和 Jessica 一起负责开发某项特性 A，而同时 Jessica 和 Josie 一起负责开发另一项功能 B。公司使用典型的集成管理员式工作流，每个组都有一名管理员负责集成本组代码，及更新项目主仓库的 <code>master</code> 分支。所有开发都在代表小组的分支上进行。</p>

<p>让我们跟随 Jessica 的视角看看她的工作流程。她参与开发两项特性，同时和不同小组的开发者一起协作。克隆生成本地仓库后，她打算先着手开发特性 A。于是创建了新的 <code>featureA</code> 分支，继而编写代码：</p>

<pre><code># Jessica&#39;s Machine
$ git checkout -b featureA
Switched to a new branch &quot;featureA&quot;
$ vim lib/simplegit.rb
$ git commit -am &#39;add limit to log function&#39;
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>

<p>此刻，她需要分享目前的进展给 John，于是她将自己的 <code>featureA</code> 分支提交到服务器。由于 Jessica 没有权限推送数据到主仓库的 <code>master</code> 分支（只有集成管理员有此权限），所以只能将此分支推上去同 John 共享协作：</p>

<pre><code>$ git push origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -&gt; featureA</code></pre>

<p>Jessica 发邮件给 John 让他上来看看 <code>featureA</code> 分支上的进展。在等待他的反馈之前，Jessica 决定继续工作，和 Josie 一起开发 <code>featureB</code> 上的特性 B。当然，先创建此分支，分叉点以服务器上的 <code>master</code> 为起点：</p>

<pre><code># Jessica&#39;s Machine
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch &quot;featureB&quot;</code></pre>

<p>随后，Jessica 在 <code>featureB</code> 上提交了若干更新：</p>

<pre><code>$ vim lib/simplegit.rb
$ git commit -am &#39;made the ls-tree function recursive&#39;
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am &#39;add ls-files&#39;
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)</code></pre>

<p>现在 Jessica 的更新历史如图 5-12 所示：</p>

<p><center><img src="/figures/ch5/18333fig0512-tn.png"></center><br/> 图 5-12. Jessica 的更新历史</p>

<p>Jessica 正准备推送自己的进展上去，却收到 Josie 的来信，说是她已经将自己的工作推到服务器上的 <code>featureBee</code> 分支了。这样，Jessica 就必须先将 Josie 的代码合并到自己本地分支中，才能再一起推送回服务器。她用 <code>git fetch</code> 下载 Josie 的最新代码：</p>

<pre><code>$ git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -&gt; origin/featureBee</code></pre>

<p>然后 Jessica 使用 <code>git merge</code> 将此分支合并到自己分支中：</p>

<pre><code>$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)</code></pre>

<p>合并很顺利，但另外有个小问题：她要推送自己的 <code>featureB</code> 分支到服务器上的 <code>featureBee</code> 分支上去。当然，她可以使用冒号（:）格式指定目标分支：</p>

<pre><code>$ git push origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -&gt; featureBee</code></pre>

<p>我们称此为<em>refspec</em>。更多有关于 Git refspec 的讨论和使用方式会在第九章作详细阐述。</p>

<p>接下来，John 发邮件给 Jessica 告诉她，他看了之后作了些修改，已经推回服务器 <code>featureA</code> 分支，请她过目下。于是 Jessica 运行 <code>git fetch</code> 下载最新数据：</p>

<pre><code>$ git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -&gt; origin/featureA</code></pre>

<p>接下来便可以用 <code>git log</code> 查看更新了些什么：</p>

<pre><code>$ git log origin/featureA ^featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25</code></pre>

<p>最后，她将 John 的工作合并到自己的 <code>featureA</code> 分支中：</p>

<pre><code>$ git checkout featureA
Switched to branch &quot;featureA&quot;
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)</code></pre>

<p>Jessica 稍做一番修整后同步到服务器：</p>

<pre><code>$ git commit -am &#39;small tweak&#39;
[featureA ed774b3] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
$ git push origin featureA
...
To jessica@githost:simplegit.git
   3300904..ed774b3  featureA -&gt; featureA</code></pre>

<p>现在的 Jessica 提交历史如图 5-13 所示：</p>

<p><center><img src="/figures/ch5/18333fig0513-tn.png"></center><br/> 图 5-13. 在特性分支中提交更新后的提交历史</p>

<p>现在，Jessica，Josie 和 John 通知集成管理员服务器上的 <code>featureA</code> 及 <code>featureBee</code> 分支已经准备好，可以并入主线了。在管理员完成集成工作后，主分支上便多出一个新的合并提交（5399e），用 fetch 命令更新到本地后，提交历史如图 5-14 所示：</p>

<p><center><img src="/figures/ch5/18333fig0514-tn.png"></center><br/> 图 5-14. 合并特性分支后的 Jessica 提交历史</p>

<p>许多开发小组改用 Git 就是因为它允许多个小组间并行工作，而在稍后恰当时机再行合并。通过共享远程分支的方式，无需干扰整体项目代码便可以开展工作，因此使用 Git 的小型团队间协作可以变得非常灵活自由。以上工作流程的时序如图 5-15 所示：</p>

<p><center><img src="/figures/ch5/18333fig0515-tn.png"></center><br/> 图 5-15. 团队间协作工作流程基本时序</p>

<h3 id='public_small_project'>Public Small Project</h3>

<p>Contributing to public projects is a bit different. Because you don’t have the permissions to directly update branches on the project, you have to get the work to the maintainers some other way. This first example describes contributing via forking on Git hosts that support easy forking. The repo.or.cz and GitHub hosting sites both support this, and many project maintainers expect this style of contribution. The next section deals with projects that prefer to accept contributed patches via e-mail.</p>

<p>First, you’ll probably want to clone the main repository, create a topic branch for the patch or patch series you’re planning to contribute, and do your work there. The sequence looks basically like this:</p>

<pre><code>$ git clone (url)
$ cd project
$ git checkout -b featureA
$ (work)
$ git commit
$ (work)
$ git commit</code></pre>

<p>You may want to use <code>rebase -i</code> to squash your work down to a single commit, or rearrange the work in the commits to make the patch easier for the maintainer to review — see Chapter 6 for more information about interactive rebasing.</p>

<p>When your branch work is finished and you’re ready to contribute it back to the maintainers, go to the original project page and click the &#8220;Fork&#8221; button, creating your own writable fork of the project. You then need to add in this new repository URL as a second remote, in this case named <code>myfork</code>:</p>

<pre><code>$ git remote add myfork (url)</code></pre>

<p>You need to push your work up to it. It’s easiest to push the remote branch you’re working on up to your repository, rather than merging into your master branch and pushing that up. The reason is that if the work isn’t accepted or is cherry picked, you don’t have to rewind your master branch. If the maintainers merge, rebase, or cherry-pick your work, you’ll eventually get it back via pulling from their repository anyhow:</p>

<pre><code>$ git push myfork featureA</code></pre>

<p>When your work has been pushed up to your fork, you need to notify the maintainer. This is often called a pull request, and you can either generate it via the website — GitHub has a &#8220;pull request&#8221; button that automatically messages the maintainer — or run the <code>git request-pull</code> command and e-mail the output to the project maintainer manually.</p>

<p>The <code>request-pull</code> command takes the base branch into which you want your topic branch pulled and the Git repository URL you want them to pull from, and outputs a summary of all the changes you’re asking to be pulled in. For instance, if Jessica wants to send John a pull request, and she’s done two commits on the topic branch she just pushed up, she can run this:</p>

<pre><code>$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
  John Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)</code></pre>

<p>The output can be sent to the maintainer—it tells them where the work was branched from, summarizes the commits, and tells where to pull this work from.</p>

<p>On a project for which you’re not the maintainer, it’s generally easier to have a branch like <code>master</code> always track <code>origin/master</code> and to do your work in topic branches that you can easily discard if they’re rejected. Having work themes isolated into topic branches also makes it easier for you to rebase your work if the tip of the main repository has moved in the meantime and your commits no longer apply cleanly. For example, if you want to submit a second topic of work to the project, don’t continue working on the topic branch you just pushed up — start over from the main repository’s <code>master</code> branch:</p>

<pre><code>$ git checkout -b featureB origin/master
$ (work)
$ git commit
$ git push myfork featureB
$ (email maintainer)
$ git fetch origin</code></pre>

<p>Now, each of your topics is contained within a silo — similar to a patch queue — that you can rewrite, rebase, and modify without the topics interfering or interdepending on each other as in Figure 5-16.</p>

<p><center><img src="/figures/ch5/18333fig0516-tn.png"></center><br/> Figure 5-16. Initial commit history with featureB work</p>

<p>Let’s say the project maintainer has pulled in a bunch of other patches and tried your first branch, but it no longer cleanly merges. In this case, you can try to rebase that branch on top of <code>origin/master</code>, resolve the conflicts for the maintainer, and then resubmit your changes:</p>

<pre><code>$ git checkout featureA
$ git rebase origin/master
$ git push –f myfork featureA</code></pre>

<p>This rewrites your history to now look like Figure 5-17.</p>

<p><center><img src="/figures/ch5/18333fig0517-tn.png"></center><br/> Figure 5-17. Commit history after featureA work</p>

<p>Because you rebased the branch, you have to specify the <code>–f</code> to your push command in order to be able to replace the <code>featureA</code> branch on the server with a commit that isn’t a descendant of it. An alternative would be to push this new work to a different branch on the server (perhaps called <code>featureAv2</code>).</p>

<p>Let’s look at one more possible scenario: the maintainer has looked at work in your second branch and likes the concept but would like you to change an implementation detail. You’ll also take this opportunity to move the work to be based off the project’s current <code>master</code> branch. You start a new branch based off the current <code>origin/master</code> branch, squash the <code>featureB</code> changes there, resolve any conflicts, make the implementation change, and then push that up as a new branch:</p>

<pre><code>$ git checkout -b featureBv2 origin/master
$ git merge --no-commit --squash featureB
$ (change implementation)
$ git commit
$ git push myfork featureBv2</code></pre>

<p>The <code>--squash</code> option takes all the work on the merged branch and squashes it into one non-merge commit on top of the branch you’re on. The <code>--no-commit</code> option tells Git not to automatically record a commit. This allows you to introduce all the changes from another branch and then make more changes before recording the new commit.</p>

<p>Now you can send the maintainer a message that you’ve made the requested changes and they can find those changes in your <code>featureBv2</code> branch (see Figure 5-18).</p>

<p><center><img src="/figures/ch5/18333fig0518-tn.png"></center><br/> Figure 5-18. Commit history after featureBv2 work</p>

<h3 id='public_large_project'>Public Large Project</h3>

<p>Many larger projects have established procedures for accepting patches — you’ll need to check the specific rules for each project, because they will differ. However, many larger public projects accept patches via a developer mailing list, so I’ll go over an example of that now.</p>

<p>The workflow is similar to the previous use case — you create topic branches for each patch series you work on. The difference is how you submit them to the project. Instead of forking the project and pushing to your own writable version, you generate e-mail versions of each commit series and e-mail them to the developer mailing list:</p>

<pre><code>$ git checkout -b topicA
$ (work)
$ git commit
$ (work)
$ git commit</code></pre>

<p>Now you have two commits that you want to send to the mailing list. You use <code>git format-patch</code> to generate the mbox-formatted files that you can e-mail to the list — it turns each commit into an e-mail message with the first line of the commit message as the subject and the rest of the message plus the patch that the commit introduces as the body. The nice thing about this is that applying a patch from an e-mail generated with <code>format-patch</code> preserves all the commit information properly, as you’ll see more of in the next section when you apply these commits:</p>

<pre><code>$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch</code></pre>

<p>The <code>format-patch</code> command prints out the names of the patch files it creates. The <code>-M</code> switch tells Git to look for renames. The files end up looking like this:</p>

<pre><code>$ cat 0001-add-limit-to-log-function.patch 
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = &#39;master&#39;)
-    command(&quot;git log #{treeish}&quot;)
+    command(&quot;git log -n 20 #{treeish}&quot;)
   end

   def ls_tree(treeish = &#39;master&#39;)
-- 
1.6.2.rc1.20.g8c5b.dirty</code></pre>

<p>You can also edit these patch files to add more information for the e-mail list that you don’t want to show up in the commit message. If you add text between the <code>--</code> line and the beginning of the patch (the <code>lib/simplegit.rb</code> line), then developers can read it; but applying the patch excludes it.</p>

<p>To e-mail this to a mailing list, you can either paste the file into your e-mail program or send it via a command-line program. Pasting the text often causes formatting issues, especially with &#8220;smarter&#8221; clients that don’t preserve newlines and other whitespace appropriately. Luckily, Git provides a tool to help you send properly formatted patches via IMAP, which may be easier for you. I’ll demonstrate how to send a patch via Gmail, which happens to be the e-mail agent I use; you can read detailed instructions for a number of mail programs at the end of the aforementioned <code>Documentation/SubmittingPatches</code> file in the Git source code.</p>

<p>First, you need to set up the imap section in your <code>~/.gitconfig</code> file. You can set each value separately with a series of <code>git config</code> commands, or you can add them manually; but in the end, your config file should look something like this:</p>

<pre><code>[imap]
  folder = &quot;[Gmail]/Drafts&quot;
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = p4ssw0rd
  port = 993
  sslverify = false</code></pre>

<p>If your IMAP server doesn’t use SSL, the last two lines probably aren’t necessary, and the host value will be <code>imap://</code> instead of <code>imaps://</code>. When that is set up, you can use <code>git send-email</code> to place the patch series in the Drafts folder of the specified IMAP server:</p>

<pre><code>$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith &lt;jessica@example.com&gt;] 
Emails will be sent from: Jessica Smith &lt;jessica@example.com&gt;
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y</code></pre>

<p>Then, Git spits out a bunch of log information looking something like this for each patch you’re sending:</p>

<pre><code>(mbox) Adding cc: Jessica Smith &lt;jessica@example.com&gt; from 
  \line &#39;From: Jessica Smith &lt;jessica@example.com&gt;&#39;
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith &lt;jessica@example.com&gt;
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: &lt;1243715356-61726-1-git-send-email-jessica@example.com&gt;
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: &lt;y&gt;
References: &lt;y&gt;

Result: OK</code></pre>

<p>At this point, you should be able to go to your Drafts folder, change the To field to the mailing list you’re sending the patch to, possibly CC the maintainer or person responsible for that section, and send it off.</p>

<h3 id='summary'>Summary</h3>

<p>This section has covered a number of common workflows for dealing with several very different types of Git projects you’re likely to encounter and introduced a couple of new tools to help you manage this process. Next, you’ll see how to work the other side of the coin: maintaining a Git project. You’ll learn how to be a benevolent dictator or integration manager.</p>

<div id='nav'>
<a href='ch5-1.html'>prev</a> | <a href='ch5-3.html'>next</a>
</div>