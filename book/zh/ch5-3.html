---
layout: translation
title: Pro Git 5.3 分布式 Git 项目的管理
---
<h2 id='id270'>项目的管理</h2>

<p>除了贡献代码，你还需要知道如何维护一个项目。这包括处理别人用<code>format-patch</code>命令产生的补丁和集成远端代码库的更新等等。但无论你是维护代码库，还是帮助别人审核、改善收到的补丁，都需要了解如何以最简洁的方式搜集贡献者的工作并和他们保持长期的合作关系。</p>

<h3 id='id271'>使用特性分支进行工作</h3>

<p>通常在加入新的代码时，先在特性分支上做个试验是个好的主意——建立一个专门用来试验这些代码的临时分支。这样就能很容易的做出一个独立的补丁，如果它不工作你还可以先放下它，等到有时间的时候再重新捡起来。创建的分支可以用相关的主题关键字命名，比如 <code>ruby_client</code> 或者其它类似的描述性词语，以帮助将来有需要的时候回忆起来。Git本身也把分支名称分置于不同的命名空间之下，比如 <code>sc/ruby_client</code>，<code>sc</code> 就是贡献这些代码的人名的缩写。</p>

<p>现在，在当前主干分支的基础上新建一个临时分支：</p>

<pre><code>    $ git branch sc/ruby_client master</code></pre>

<p>另外，如果你希望立即转到分支上去工作，可以使用<code>checkout -b</code>：</p>

<pre><code>    $ git checkout -b sc/ruby_client master</code></pre>

<p>好了，现在已经准备妥当，可以试着将别人贡献的代码合并进来了。之后评估一下有没有问题，最后再决定是不是真的要并入主干。</p>

<h3 id='id272'>采纳来自邮件的补丁</h3>

<p>如果你收到了一个通过E-mail发来的补丁，你应该先把它应用到一个特性分支上进行评估。有两种应用补丁的方法：<code>git apply</code> 或者 <code>git am</code>。</p>

<h4 id='_apply_'>使用 apply 命令应用补丁</h4>

<p>如果你收到某人使用<code>git diff</code>或者Unix的 <code>diff</code>命令生成的补丁，可以使用<code>git apply</code>命令来应用它们。假定你把补丁保存在<code>/tmp/patch-ruby-client.patch</code>，可以这样应用补丁：</p>

<pre><code>$ git apply /tmp/patch-ruby-client.patch</code></pre>

<p>它会修改你工作目录下的文件。效果基本与运行<code>patch -p1</code>命令打补丁一样，但是它更加严格并且不会出现混乱。如果它是<code>git diff</code>格式描述的补丁，还会处理文件的添加，删除和重命名等操作,<code>patch</code>命令根本做不到这一点。最后，<code>git apply</code>是一个&#8221;apply all or abort all&#8221;模式的命令,要么所有补丁都打上去，要么都没有，但是<code>patch</code>命令会部分的应用补丁文件，可能导致你的工作变得不完整且非常混乱。<code>git apply</code>比<code>patch</code>严格很多，但是它不会自动commit——运行它之后，你必须手动stage，然后commit。</p>

<p>你还可以在真正打补丁之前检验一下——使用<code>git apply --check</code>来查看补丁是否能够干净的应用。</p>

<pre><code>$ git apply --check 0001-seeing-if-this-helps-the-gem.patch 
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply</code></pre>

<p>如果没有任何输出，表示补丁被干净的应用了。如果检验失败，这个命令将返回一个非零的状态，需要的话你可以把它用在脚本里。</p>

<h4 id='_am_'>使用 am 命令应用补丁</h4>

<p>如果贡献者也使用Git，并且擅长于使用<code>format-patch</code>来制作他的补丁，那么你的工作将会更加轻松，因为这样的补丁里包含了作者信息和commit信息。请鼓励你的贡献者们使用<code>format-patch</code>代替<code>diff</code>。另外，<code>git apply</code>应该只用在老式补丁上。</p>

<p>应用一个由<code>format-patch</code>制作的新式补丁,应该使用<code>git am</code>。技术上说，<code>git am</code>读取mbox文件——它是一个简单的，纯文本格式的文件。它保存着一或多个e-mail信息，就像这样：</p>

<pre><code>From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20</code></pre>

<p>这是<code>format-patch</code>命令输出的开头几行，也是一个有效的mbox电邮格式。如果有人用<code>git send-email</code>给你发了一个补丁，你可以将它下载到本地，然后运行<code>git am</code>命令来应用这个补丁。如果你的E-mail客户端能够将多个e-mail文件保存到一起，就可以这样做——把多个相关补丁保存到一个文件里，然后使用<code>git am</code>一次应用所有的补丁。</p>

<p>同样的，如果某人上传了一个由<code>format-patch</code>制作的补丁文件让大家投票决定是否采纳时，你可以将该文件保存到本地并使用<code>git am</code>应用这个补丁，之后开始评估它：</p>

<pre><code>$ git am 0001-limit-log-function.patch 
Applying: add limit to log function</code></pre>

<p>你会看到它被干净的应用并自动建立了新的commit。作者信息取自e-mail头部的<code>From</code>和<code>Date</code>字段，commit的信息取自<code>Subject</code>字段和正文（补丁之前的内容）。举个例子，如果这个补丁来自我刚刚展示的那个mbox邮件，commit信息看起来就像这样：</p>

<pre><code>$ git log --pretty=fuller -1
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Author:     Jessica Smith &lt;jessica@example.com&gt;
AuthorDate: Sun Apr 6 10:17:23 2008 -0700
Commit:     Scott Chacon &lt;schacon@gmail.com&gt;
CommitDate: Thu Apr 9 09:19:06 2009 -0700

   add limit to log function

   Limit log functionality to the first 20</code></pre>

<p><code>Commit</code>部分显示了提交者的信息和提交日期。<code>Author</code>部分显示了原作者信息和补丁的创建时间。</p>

<p>有时,补丁不能被干净的应用。这可能是你的主干分支和补丁的基础分支相差太远了，也可能是这个补丁依赖于一些你还没加入的补丁。这种情况下，<code>git am</code>会报错并询问你该怎么做：</p>

<pre><code>$ git am 0001-seeing-if-this-helps-the-gem.patch 
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Patch failed at 0001.
When you have resolved this problem run &quot;git am --resolved&quot;.
If you would prefer to skip this patch, instead run &quot;git am --skip&quot;.
To restore the original branch and stop patching run &quot;git am --abort&quot;.</code></pre>

<p>Git 会在有冲突的文件里加入冲突解决标记，很像有冲突的合并（merge）或者衍合（rebase）操作产生的结果。解决问题的方法也一样——首先编辑文件消除冲突，然后暂存（stage）新文件，最后运行<code>git am --resolved</code>继续应用下一个补丁：</p>

<pre><code>$ (fix the file)
$ git add ticgit.gemspec 
$ git am --resolved
Applying: seeing if this helps the gem</code></pre>

<p>如果你想要Git尝试用更智能的方法来解决冲突，可以使用<code>-3</code>选项进行一次三方合并。这个选项默认是不开启的，因为如果这个补丁的基础代码和你的代码库不同将会导致错误。如果你的代码库和补丁的基准代码有共同的祖先，那么<code>-3</code>选项将会更加智能的应用这个有争议的补丁。</p>

<pre><code>$ git am -3 0001-seeing-if-this-helps-the-gem.patch 
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
No changes -- Patch already applied.</code></pre>

<p>重复应用同一个补丁会产生冲突，加上<code>-3</code>选项就可以解决这样的问题。</p>

<p>如果你一次应用多个mbox格式的补丁，可以使用<code>am</code>命令的交互模式，这样就会在每个补丁前停住，然后询问你如何操作。</p>

<pre><code>$ git am -3 -i mbox
Commit Body is:
--------------------------
seeing if this helps the gem
--------------------------
Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all </code></pre>

<p>在一次应用多个补丁的情况下，这是一个非常好的方法，如果你忘了补丁的内容，可以先浏览一下。或者，那些你已经应用过的补丁就不需要再次应用了。</p>

<p>当所有这些针对新特性的补丁都被评估后，你就可以决定是否在长期分支中将他们集成进来。</p>

<h3 id='id273'>检出远程分支</h3>

<p>如果你的贡献者建立了自己的Git代码库，并且他将自己的修改都推送到这个代码库里。需要合并代码时，他会将他代码库的URL连同分支的名字一起发过来，然后你应该把这些分支加为远程分支并且开始本地合并。</p>

<p>比如，Jessica给你发了个邮件，告诉你她代码库里的<code>ruby-client</code>分支上有一个非常棒的特性，你就可以引入这个远程分支，然后将代码检出到本地来进行测试。</p>

<pre><code>$ git remote add jessica git://github.com/jessica/myproject.git
$ git fetch jessica
$ git checkout -b rubyclient jessica/ruby-client</code></pre>

<p>如果，过了一会她又发邮件给你，说她还有一个很棒的特性在另外一个分支上，你只需要获取（fetch）然后检出（checkout），因为前面已经引入了那个远程分支。</p>

<p>这样做非常便于和别人保持长期的合作关系。但是，这要求贡献者都有自己的服务器，也需要你为每个人创建一个远程分支。有些贡献者提交代码补丁不是很频繁，这时通过邮件接收补丁效率会更高。因为，你自己也不希望创建几百个分支，并且每个分支只用来接收一两个补丁。不过，脚本和托管服务会简化这个过程——根据不同的开发模式会有不同的实现方式。</p>

<p>利用远程分支的另外一个好处是：能够得到提交历史。尽管如何合理的合并代码还是个问题，但至少不用担心提交历史的差异；默认使用三方合并，不需要提供<code>-3</code>选项，可以很好的解决补丁和代码不匹配的问题。</p>

<p>如果你没有和某人长期合作，但还是希望以远程分支的方式从他那拉取代码的话，你可以使用<code>git pull</code>命令加上远程库的URL。这将执行一次拉取动作又不会把这个URL存为远程分支。</p>

<pre><code>$ git pull git://github.com/onetimeguy/project.git
From git://github.com/onetimeguy/project
 * branch            HEAD       -&gt; FETCH_HEAD
Merge made by recursive.</code></pre>

<h3 id='id274'>决定该引入的代码</h3>

<p>现在，特性分支上已经合并好了贡献代码，是时候决定如何处置它们了。本节将回顾一些以前学过的命令，以便你能够准确的找出执行合并（merge）操作时将被合并进主干的代码。</p>

<p>查看特性分支上新增的commit信息是非常有用的操作。在特性分支名字后面加上<code>--not</code>选项就会显示这些信息。比如，你建立了一个叫做<code>contrib</code>的特性分支并打上了两个补丁，你可以运行：</p>

<pre><code>$ git log contrib --not master
commit 5b6235bd297351589efc4d73316f0a68d484f118
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Oct 24 09:53:59 2008 -0700

    seeing if this helps the gem

commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Mon Oct 22 19:38:36 2008 -0700

    updated the gemspec to hopefully work better</code></pre>

<p>还可以查看每次commit的具体修改。请牢记在<code>git log</code>后加上<code>-p</code>选项，将展示每次commit的diff。</p>

<p>如果想看看特性分支和其他分支merge时的完整的diff信息，需要一个更高级的技巧。你可能会想到这样做：</p>

<pre><code>$ git diff master</code></pre>

<p>这个命令的确会产生一个diff输出，但是它可能是错误的。如果在你建立特性分支之后<code>master</code>分支有过快进（move forward）操作，你得到的输出将是不正确的。这是因为这个Git命令只会简单的比较特性分支和<code>master</code>分支最后一次快照之间的区别。举例来说，如果你在<code>master</code>分支中的某个文件中加了一行，简单的比较最新快照所得到的结论只能是：特性分支中删除了这一行。</p>

<p>如果<code>master</code>分支是特性分支的直接祖先，不会产生任何问题；但是如果他们两个在不同的分叉上，产生的diff输出看起来就像是增加了特性分支上的所有新增代码，而删除了<code>master</code>分支上的所有新增代码。</p>

<p>其实，你真正想看到的是新加入到特性分支的代码——也就是合并时会并入主干的代码。你应该比较的是特性分支与它和master分支共同祖先的差异。</p>

<p>技术上说，你可以找出他们的共同祖先，然后与之比较：</p>

<pre><code>$ git merge-base contrib master
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
$ git diff 36c7db </code></pre>

<p>但是这样很不方便，所以Git提供了另外一种捷径：三点符号。这样的情景下，可以把三点符号加在当前分支之前，被比较的拥有共同祖先的分支之后（有点拗口，看例程吧）：</p>

<pre><code>$ git diff master...contrib</code></pre>

<p>这个命令展示了当前特性分支与它和master分支共同祖先的差异。这是一个非常有用的命令，应该牢记。</p>

<h3 id='id275'>集成贡献的代码</h3>

<p>特性分支内的工作都完成了，只等待被加入到更主线一些的分支中。随之而来的问题是：该怎样做？还有，维护项目的总体步骤是什么？其实选择有很多，我们这里只介绍其中的一部分。</p>

<h4 id='id276'>合并代码的流程</h4>

<p>首先介绍一个简单的合并代码流程：假设你的<code>master</code>分支包含稳定的代码，然后你在一个分支上开发新的特性直到完成（或者审核完别人贡献的代码），接着你把它并入主干分支，最后删除这个多余的分支，再次开头重复这个开发流程。如果代码库里有两个分支，分别叫<code>ruby_client</code> and <code>php_client</code>，见图5-19。然后你先把<code>ruby_client</code>合并进主干，再合并<code>php_client</code>，最后的提交历史类似于图5-20。</p>

<p><center><img src="/figures/ch5/18333fig0519-tn.png"></center><br/> Figure 5-19. 多个特性分支</p>

<p><center><img src="/figures/ch5/18333fig0520-tn.png"></center><br/> Figure 5-20. 合并特性分支之后</p>

<p>这是最简单的流程，所以在处理大一些的项目时可能会有问题。</p>

<p>如果维护一个有很多开发者的大项目，至少需要将合并过程分为两步。假设你有两个长期分支<code>master</code>和<code>develop</code>，<code>develop</code>分支用来合并新的代码，<code>master</code>分支则只升级到稳定的发行版本。通常这两个分支都会被推送到公开的代码库。每次有新的特性需要合并的时候（图 5-21），首先将它并入<code>develop</code>（图 5-22）；之后，如果有了一个稳定的发行版，<code>master</code>会快进到稳定的<code>develop</code>分支处（图 5-23）。</p>

<p><center><img src="/figures/ch5/18333fig0521-tn.png"></center><br/> Figure 5-21. 合并特性分支之前</p>

<p><center><img src="/figures/ch5/18333fig0522-tn.png"></center><br/> Figure 5-22. 合并特性分支之后</p>

<p><center><img src="/figures/ch5/18333fig0523-tn.png"></center><br/> Figure 5-23. 特性分支发布之后</p>

<p>这样，人们在clone你的代码库时就会有两个选择：他们可以检出最新的稳定版本的代码，并且还能很方便的跟上更新。也可以检出开发分支，这样就能得到最前沿的特性。</p>

<p>你也可以扩展这个概念。将所有的代码合并到一个单独的分支，等到这个分支上的代码稳定并通过测试后，再将它并入develop分支。然后，如果这些代码能够稳定的工作一段时间并有理由相信它足够稳定了，再将主干分支快进到这里。</p>

<h4 id='id277'>大项目的合并流程</h4>

<p>Git项目有四个长期分支：<code>master</code>, <code>next</code>,和<code>pu</code>（建议继续修改）针对新代码的，还有<code>maint</code>用来维护除错的。维护者将贡献者的代码并入不同的特性分支，方法类似于我上面提到的那样（见图5-24）。之后，测试特性看看他们是能够安全的工作，否则就需要继续修改。</p>

<p><center><img src="/figures/ch5/18333fig0524-tn.png"></center><br/> Figure 5-24. 管理复杂的并行贡献</p>

<p>如果这些代码可以安全的工作，可以把他们合并进<code>next</code>分支，并推送到公开库来让更多的人试试这个新加入的特性。</p>

<p>如果这些代码还需要修改，就将他们合并进<code>pu</code>分支。当他们完全稳定时，这个特性就会重新并入<code>master</code>，同时也检查一下<code>next</code>分支，将足够稳定的特性并入<code>master</code>。也就是说<code>master</code>始终是快进的，<code>next</code>偶尔需要rebased，<code>pu</code>经常需要rebased（见图 5-25）</p>

<p><center><img src="/figures/ch5/18333fig0525-tn.png"></center><br/> Figure 5-25. 将特性并入长期分支</p>

<p>当一个特性分支最终合并进<code>master</code>之后，它将被从代码库里删除。Git项目还有一个<code>maint</code>分支，它是以最近的发行版为基础派生（fork）出来的，用来提供除错补丁。所以，当你克隆（clone）Git的代码库时，实际上得到四个分支，你可以检出不同的分支来了解不同的开发阶段。这取决于你想得到多么前沿的特性或者做什么样的贡献；维护者都有一个结构化的流程来帮助他们审查新的贡献。</p>

<h4 id='cherrypick'>衍合与挑拣（cherry-pick）的流程</h4>

<p>一些维护者更喜欢衍合或者挑拣贡献者的代码，而不是简单的合并，因为这样能够保持线性的提交历史。如果你完成了一个特性的开发，并决定将它引入到主干代码中，你可以转到那个特性分支然后执行衍合命令，好在你的主干分支上（也可能是<code>develop</code>分支之类的）重新提交这些修改。如果这些代码工作得很好，你就可以快进<code>master</code>分支，得到一个线性的提交历史。</p>

<p>另一个引入代码的方法是挑拣。挑拣类似于针对某次特定提交的衍合。它首先提取某次提交的补丁，然后试着应用在当前分支上。如果某个特性分支上有多个commits，但你只想引入其中之一就可以使用这种方法。也可能仅仅是因为你喜欢用挑拣，讨厌衍合。假设你有一个类似图 5-26的工程。</p>

<p><center><img src="/figures/ch5/18333fig0526-tn.png"></center><br/> Figure 5-26. 挑拣（cherry-pick）之前的历史</p>

<p>如果你希望拉取<code>e43a6</code>到你的主干分支，可以这样：</p>

<pre><code>$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf
Finished one cherry-pick.
[master]: created a0a41a9: &quot;More friendly message when locking the index fails.&quot;
 3 files changed, 17 insertions(+), 3 deletions(-)</code></pre>

<p>这将会引入<code>e43a6</code>的代码，但是会得到不同的SHA-1值，因为应用日期不同。现在你的历史看起来像图 5-27.</p>

<p><center><img src="/figures/ch5/18333fig0527-tn.png"></center><br/> Figure 5-27. 挑拣（cherry-pick）之后的历史</p>

<p>现在，你可以删除这个特性分支并丢弃你不想引入的那些commit。</p>

<h3 id='id278'>给发行版签名</h3>

<p>你可以删除上次发布的版本并重新打标签，也可以像第二章所说的那样建立一个新的标签。如果你决定以维护者的身份给发行版签名，应该这样做：</p>

<pre><code>$ git tag -s v1.5 -m &#39;my signed 1.5 tag&#39;
You need a passphrase to unlock the secret key for
user: &quot;Scott Chacon &lt;schacon@gmail.com&gt;&quot;
1024-bit DSA key, ID F721C45A, created 2009-02-09</code></pre>

<p>完成签名之后，如何分发PGP公钥（public key）是个问题。（译者注：分发公钥是为了验证标签）。还好，Git的设计者想到了解决办法：可以把key（既公钥）作为blob变量写入Git库，然后把它的内容直接写在标签里。<code>gpg --list-keys</code>命令可以显示出你所拥有的key：</p>

<pre><code>$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
uid                  Scott Chacon &lt;schacon@gmail.com&gt;
sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]</code></pre>

<p>然后，导出key的内容并经由管道符传递给<code>git hash-object</code>，之后钥匙会以blob类型写入Git中，最后返回这个blob量的SHA-1值：</p>

<pre><code>$ gpg -a --export F721C45A | git hash-object -w --stdin
659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre>

<p>现在你的Git已经包含了这个key的内容了，可以通过不同的SHA-1值指定不同的key来创建标签。</p>

<pre><code>$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre>

<p>在运行<code>git push --tags</code>命令之后，<code>maintainer-pgp-pub</code>标签就会公布给所有人。如果有人想要校验标签，他可以使用如下命令导入你的key：</p>

<pre><code>$ git show maintainer-pgp-pub | gpg --import</code></pre>

<p>人们可以用这个key校验你签名的所有标签。另外，你也可以在标签信息里写入一个操作向导，用户只需要运行<code>git show &lt;tag&gt;</code>查看标签信息，然后按照你的向导就能完成校验。</p>

<h3 id='id279'>生成内部版本号</h3>

<p>因为Git不会为每次提交自动附加类似&#8217;v123&#8217;的递增序列，所以如果你想要得到一个便于理解的提交号可以运行<code>git describe</code>命令。Git将会返回一个字符串，由三部分组成：最近一次标定的版本号，加上自那次标定之后的提交次数，再加上一段SHA-1值of the commit you’re describing：</p>

<pre><code>$ git describe master
v1.6.2-rc1-20-g8c5b85c</code></pre>

<p>这个字符串可以作为快照的名字，方便人们理解。如果你的Git是你自己下载源码然后编译安装的，你会发现<code>git --version</code>命令的输出和这个字符串差不多。如果在一个刚刚打完标签的提交上运行<code>describe</code>命令，只会得到这次标定的版本号，而没有后面两项信息。</p>

<p><code>git describe</code>命令只适用于有标注的标签（通过<code>-a</code>或者<code>-s</code>选项创建的标签），所以发行版的标签都应该是带有标注的，以保证<code>git describe</code>能够正确的执行。你也可以把这个字符串作为<code>checkout</code>或者<code>show</code>命令的目标，因为他们最终都依赖于一个简短的SHA-1值，当然如果这个SHA-1值失效他们也跟着失效。最近Linux内核为了保证SHA-1值的唯一性，将位数由8位扩展到10位，这就导致扩展之前的<code>git describe</code>输出完全失效了。</p>

<h3 id='id280'>准备发布</h3>

<p>现在可以发布一个新的版本了。首先要将代码的压缩包归档，方便那些可怜的还没有使用Git的人们。可以使用<code>git archive</code>：</p>

<pre><code>$ git archive master --prefix=&#39;project/&#39; | gzip &gt; `git describe master`.tar.gz
$ ls *.tar.gz
v1.6.2-rc1-20-g8c5b85c.tar.gz</code></pre>

<p>这个压缩包解压出来的是一个文件夹，里面是你项目的最新代码快照。你也可以用类似的方法建立一个zip压缩包，在<code>git archive</code>加上<code>--format=zip</code>选项：</p>

<pre><code>$ git archive master --prefix=&#39;project/&#39; --format=zip &gt; `git describe master`.zip</code></pre>

<p>现在你有了一个tar.gz压缩包和一个zip压缩包，可以把他们上传到你网站上或者用e-mail发给别人。</p>

<h3 id='id281'>制作简报</h3>

<p>是时候通知邮件列表里的朋友们来检验你的成果了。使用<code>git shortlog</code>命令可以方便快捷的制作一份修改日志（changelog），告诉大家上次发布之后又增加了哪些特性和修复了哪些bug。实际上这个命令能够统计给定范围内的所有提交;假如你上一次发布的版本是v1.0.1，下面的命令将给出自从上次发布之后的所有提交的简介：</p>

<pre><code>$ git shortlog --no-merges master --not v1.0.1
Chris Wanstrath (8):
      Add support for annotated tags to Grit::Tag
      Add packed-refs annotated tag support.
      Add Grit::Commit#to_patch
      Update version and History.txt
      Remove stray `puts`
      Make ls_tree ignore nils

Tom Preston-Werner (4):
      fix dates in history
      dynamic version method
      Version bump to 1.0.2
      Regenerated gemspec for version 1.0.2</code></pre>

<p>这就是自从v1.0.1版本以来的所有提交的简介，内容按照作者分组，以便你能快速的发e-mail给他们。</p>

<div id='nav'>
<a href='ch5-2.html'>prev</a> | <a href='ch5-4.html'>next</a>
</div>