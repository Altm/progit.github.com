---
layout: master
title: Pro Git 5.1 Distributed Git Distributed Workflows
---
<h2 id='distributed_workflows'>Distributed Workflows</h2>

<p>Unlike centralized version control systems, the distributed nature of Git allows us to be far more flexible in how developers collaborate on projects. In centralized systems, every developer is a node working more or less equally on a central hub. In Git however, every developer is potentially both a node and a hub - that is, every developer can both contribute code to other repositories and maintain a public repository that others can base their work off of and contribute to. This opens up a vast range of workflow possibilities for your project and/or your team, so we&#8217;ll cover a few common paradigms that take advantage of this flexibility. We will go over the strengths and possible weaknesses of each design, but you can choose a single one to utilize or mix and match features from each.</p>

<h3 id='centralized_workflow'>Centralized Workflow</h3>

<p>In centralized systems, there is generally a single collaboration model - the centralized workflow. There is one central hub, or repository, that can accept code and that everyone synchronizes their work to. There are then a number of developers that are nodes, consumers of that hub, that synchronize to that one place.</p>

<p><img src='/images/ch5/workflow-star.png' alt='Centralized Workflow' /></p>

<p>This means that if two developers clone from the hub, both make changes, then the first one to push their changes back up will do so with no problems. The second one will have to merge the first one&#8217;s work in before they can push changes up so as not to overwrite the first user&#8217;s changes. This concept is equally true in Git as in Subversion (or any centralized VCS), and this model works perfectly well in Git.</p>

<p>If you have a small team or are already comfortable with a centralized workflow in your company or team, you can continue using that workflow with Git very easily. Simply setup a single repository and give everyone on your team push access and Git will not allow users to overwrite each other - if another developer has pushed since the last time you fetched and merged, it will tell the next developer that tries to push that they are not pushing an upstream commit and will deny them the ability to push until they fetch and merge the newest changes.</p>

<p>sop: Perhaps we should clarify the exact error message in the last sentence. Its awkward to read &#8220;not pushing an upstream commit&#8221; and to be honest I don&#8217;t know what this means.</p>

<p>This workflow is pretty attractive to a lot of people because it is a paradigm that many are familiar and comfortable with.</p>

<h3 id='integration_manager_workflow'>Integration Manager Workflow</h3>

<p>Since Git allows you to have multiple remote repositories, it is possible to have a workflow where each developer has write access to their own public repository and read access to everyone elses. In this scenario there is often a canonical repository that represents the &#8216;official&#8217; project. To contribute to that project, you create your own public clone of the project and push your changes to it. Then you can send a request to the maintainer of the main project to pull your changes in. They can then add your repository as a remote, test your changes locally, merge them into their branch and push back to their repository.</p>

<ul>
<li>Project maintainer pushes to their public repository</li>

<li>A contributor clones that repository and makes changes</li>

<li>The contributor pushes to their own public copy</li>

<li>The contributor sends the maintainer an email asking them to pull changes</li>

<li>The maintainer adds the contributor&#8217;s repo as a remote and merges locally</li>

<li>The maintainer pushes merged changes to the main repository</li>
</ul>

<p><img src='/images/ch5/workflow-integration.png' alt='Integration Manager Workflow' /></p>

<p>This is a very common workflow with sites like GitHub, where it is very easy to fork a project and push your changes into your fork for everyone to see. One of the main advantages of this is that you can continue to work and the maintainer of the main repository can pull your changes in at any time. Contributors don&#8217;t have to wait for the project to incorporate their changes - it allows each party to work at their own pace.</p>

<h3 id='dictator_and_lieutenants_workflow'>Dictator and Lieutenants Workflow</h3>

<p>This is a variant of the multiple repository workflows. It is generally used by huge projects with hundreds of collaborators; one famous example is the Linux kernel. In this case, there are various integration managers in charge of certain parts of the repository, those are called lieutenants and all the lieutenants have one integration manager or &#8220;benevolent dictator&#8221;. In this case, the benevolent dictatorâ€™s repository serves as the reference repository all the collaborators needs to pull from. In other words:</p>

<ul>
<li>Regular developers work on their topic branch and rebase their work on top of master</li>

<li>The master branch is the one of the dictator</li>

<li>Lieutenants merge the topic branches of the developers into their master branch</li>

<li>The dictator merges the master branch of the lieutenants into his or her master branch</li>

<li>The dictator pushes his master to the reference repository so that the other developers can rebase on it</li>
</ul>

<p><img src='/images/ch5/workflow-dictator.png' alt='Dictator Workflow' /></p>

<p>sop: lieutenants also pull from blessed repository, please add these edges.</p>

<p>This kind of workflow is not very common but can be useful in very big projects or in highly hierarchical environments as it allows the project leader (ie the dictator) to delegate much of the work and collects large subsets of code at multiple points before integrating them.</p>

<p>These are some commonly used workflows that are possible with a distributed system like Git, but you can see how there can be many variations of these to suit your particular real world workflow. Now that you can hopefully see which particular workflow combination might work for you, we&#8217;ll cover some more specific examples of how to accomplish the main roles that comprise the different flows. ## Contributing to a Project ##</p>

<p>Now you know what the different workflows are and you should have a pretty good grasp of fundamental Git usage. In this section we will cover a few common patterns for contributing to a project.</p>

<p>Now, the main difficulty with describing this is that there are a huge number of variations on how this is done. Since Git is very flexible there are many ways that people can and do work together, so it is somewhat problematic to describe how you should contribute to a project - every project is going to be a bit different. Some of the variables involved are active contributor size, choosen workflow, your commit access and possibly external contribution method.</p>

<p>The first variable is <em>active contributor size</em>. How many users are actively contributing code to this project and how often? In many instances this will be just two or three developers with a few commits a day or possibly less for slightly dormant projects. For really large companies or projects this could be in the thousands with dozens or even hundreds of patches coming in each day. This is important because with more and more developers you run into more issues with making sure your code applies cleanly or can be easily merged. Changes you do submit may be rendered obsolete or severely broken by work that is merged in while you were working on it or while it was waiting to be approved or applied. How can you keep your code consistently up to date and your patches valid?</p>

<p>The next variable is the <em>workflow</em> that is in use for the project. Is it centralized with each developer having equal write access to the main codeline? Does the project have a maintainer or integration manager that checks all of the patches? Are all of the patches peer-reviewed and approved somehow? Are you involved in that process? Is there a lieutenant system in place and do you have to submit your work to them first?</p>

<p>The next issue is your <em>commit access</em>. The workflow required in order to contribute to a project will be a lot different if you have write access to the project than if you don&#8217;t. If you do not have write access, how does the project prefer to accept contributed work? Do they even have a policy? How much work are you contributing at a time? How often will you be contributing?</p>

<p>All of these questions can effect how you contribute effectively to a project and what workflows are preferred or even available to you. We&#8217;ll cover aspects of each of these in a series of use cases, moving from simple to more complex - hopefully you will be able to construct whatever specific workflows you&#8217;ll need in practice from these examples.</p>

<h3 id='commit_guidelines'>Commit Guidelines</h3>

<p>Before we start looking at the specific use cases, a quick note about commit messages. Having a good guideline for creating commits and sticking to it makes working with Git itself and collaborating with others a lot easier. The Git project provides a nice document that lays out a number of good tips for creating commits to submit patches from - you can read it in the Git source code at:</p>

<pre><code>Documentation/SubmittingPatches</code></pre>

<p>First, you don&#8217;t want to submit any whitespace errors. Git provides an easy way to check for this - before you commit, run <code>git diff --check</code>, which will identify possible whitespace errors and list them out for you. Here is an example, where I&#8217;ve replaced a red terminal color with &#8216;X&#8217;s.</p>

<pre><code>$ git diff --check
lib/simplegit.rb:5: trailing whitespace.
+    @git_dir = File.expand_path(git_dir)XX
lib/simplegit.rb:7: trailing whitespace.
+ XXXXXXXXXXX
lib/simplegit.rb:26: trailing whitespace.
+    def command(git_cmd)XXXX</code></pre>

<p>If you run that before committing, you can tell if you&#8217;re about to commit whitespace issues that may annoy other developers.</p>

<p>Next, try to make each commit a logically separate changeset. If you can, try to make your changes digestable - don&#8217;t code for a whole weekend on five different issues and then submit them all as one massive commit on Monday. Even if you don&#8217;t commit during the weekend, use the staging area on Monday to split up your work into at least one commit per issue with a useful message per commit. If some of the changes modified the same file, try to use <code>git add --patch</code> to partially stage files (covered in detail in Chapter 6). The project snapshot at the tip of the branch will be identical whether you do one commit or five as long as all the changes get added at some point, so try to make things easier on your fellow developers when they have to review your changes. It also makes it easier to pull out or revert one of the changesets if you need to later. Chapter 6 describes a number of useful Git tricks for rewriting history and interactively staging files - make use of these tools to help craft a clean and understandable history.</p>

<p>The last thing to keep in mind is the commit message itself. Getting in the habit of creating quality commit messages makes using and collaborating with Git a lot easier. As a general rule, your messages should start with a single line, no more than about 50 characters describing the changeset concisely, followed by a blank line, followed by a more detailed explanation. The Git project requires the more detailed explanation to include your motivation for the change, and to contrast its implementation with previous behaviour - this is a good guideline to follow. It is also a good idea to use the imperative present tense in these messages. In other words, use commands. Instead of &#8220;I added tests for&#8221; or &#8220;Adding tests for&#8221;, use &#8220;Add tests for&#8221;.</p>

<p>Here is a nice template, originally written by Tim Pope at tpope.net.</p>

<pre><code>Short (50 chars or less) summary of changes

More detailed explanatory text, if necessary.  Wrap it to about 72
characters or so.  In some contexts, the first line is treated as the
subject of an email and the rest of the text as the body.  The blank
line separating the summary from the body is critical (unless you omit
the body entirely); tools like rebase can get confused if you run the
two together.

Further paragraphs come after blank lines.

 - Bullet points are okay, too

 - Typically a hyphen or asterisk is used for the bullet, preceded by a
   single space, with blank lines in between, but conventions vary here

 - Use a hanging indent</code></pre>

<p>DWP: I&#8217;m not sure what the last suggestion (use a hanging indent) is actually sugesting. Use a hanging indent where?</p>

<p>If all of your commit messages look like this, things are going to be a lot easier for you and the developers you work with. The Git project itself has very well formatted commit messages - I encourage you to run <code>git log --no-merges</code> there to see what a nicely formatted project commit history looks like.</p>

<p>In the following examples, and indeed throughout most of this book, for the sake of brevity I do not format messages nicely like this but instead use the <code>-m</code> option to <code>git commit</code>. Do as I say, not as I do.</p>

<h3 id='private_small_team'>Private Small Team</h3>

<p>The simplest setup that you&#8217;re likely to encouter is a private project with one or two other developers. By &#8216;private&#8217;, I mean closed source - not read accessible to the outside world. You and the other developers all have push access to the repository.</p>

<p>In this environment you can basically follow a similar workflow to what you might do when using Subversion or another centralized system. You still get the advantages of things like offline committing and vastly simpler branching and merging, but the workflow itself can be very similar - the main difference being that merges happen client side rather than on the server at commit time.</p>

<p>So let&#8217;s see what two developers just starting to work together with a shared repository might look like. The first developer, John, clones the repository, makes a change and commits locally. I&#8217;ll be replacing the protocol messages with &#8217;&#8230;&#8217; in these examples to shorten them somewhat.</p>

<pre><code># John&#39;s Machine
$ git clone john@githost:simplegit.git
Initialized empty Git repository in /home/john/simplegit/.git/
...
$ cd simplegit/
$ vim lib/simplegit.rb 
$ git commit -am &#39;removed invalid default value&#39;
[master 738ee87] removed invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>

<p>The second developer, Jessica, then does the same thing - clones the repository and commtis a change.</p>

<pre><code># Jessica&#39;s Machine
$ git clone jessica@githost:simplegit.git
Initialized empty Git repository in /home/jessica/simplegit/.git/
...
$ cd simplegit/
$ vim TODO 
$ git commit -am &#39;add reset task&#39;
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre>

<p>Now Jessica pushes her work up to the server.</p>

<pre><code># Jessica&#39;s Machine
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -&gt; master</code></pre>

<p>Now John tries to push his change up too.</p>

<pre><code># John&#39;s Machine
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -&gt; master (non-fast forward)
error: failed to push some refs to &#39;john@githost:simplegit.git&#39;</code></pre>

<p>John is not allowed to push because Jessica has pushed in the meantime. This is especially important to understand if you are used to Subversion, because you&#8217;ll notice that they did not edit the same file. While Subversion will automatically do this merge on the server if different files are edited, in Git we&#8217;ll have to merge the commits locally. Now John will have to fetch Jessica&#8217;s changes and merge them in before he will be allowed to push.</p>

<pre><code>$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -&gt; origin/master</code></pre>

<p>So at this point John&#8217;s local repository looks something like this:</p>

<p>FIG: simplea-1</p>

<p>John has a reference to the changes Jessica pushed up, but has to merge them into his own work before he is allowed to push.</p>

<pre><code>$ git merge origin/master
Merge made by recursive.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre>

<p>The merge went smoothly - John&#8217;s commit history now looks like this:</p>

<p>FIG: simplea-2</p>

<p>Now John can test his code to make sure it still works properly and then he can push his new merged work up to the server.</p>

<pre><code>$ git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -&gt; master</code></pre>

<p>Finally, John&#8217;s commit history looks like this:</p>

<p>FIG: simplea-3</p>

<p>In the meantime, Jessica has been working on a topic branch. She created a topic branch called &#8216;issue54&#8217; and has done three commits on that branch. She hasn&#8217;t fetched John&#8217;s changes yet, so her commit history looks like this:</p>

<p>FIG: simpleb-1</p>

<p>Now Jessica wants to sync up with John, so she fetches.</p>

<pre><code># Jessica&#39;s Machine
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -&gt; origin/master</code></pre>

<p>That pulls down the work that John has pushed up in the meantime and her history now looks like this:</p>

<p>FIG: simpleb-2</p>

<p>Now Jessica thinks her topic branch is ready, but she wants to know what she will have to merge her work into so that she can push. She can run <code>git log</code> to find that out.</p>

<pre><code>$ git log --no-merges origin/master ^issue54
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 16:01:27 2009 -0700

    removed invalid default value</code></pre>

<p>Now Jessica can merge her topic work into her master branch, then merge John&#8217;s work (&#8216;origin/master&#8217;) into her master branch, and then push back to the server again. First, she switches back to her master branch to integrate all of this work.</p>

<pre><code>$ git checkout master
Switched to branch &quot;master&quot;
Your branch is behind &#39;origin/master&#39; by 2 commits, and can be fast-forwarded.</code></pre>

<p>Now she can either merge &#8216;origin/master&#8217; or &#8216;issue54&#8217; first - they are both upstream so the order doesn&#8217;t really matter - the end snapshot should be identical no matter which order she does it, only the history will be slightly different. She chooses to merge in &#8216;issue54&#8217; first.</p>

<p>sop: I&#8217;d merge origin/master first.</p>

<pre><code>$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)</code></pre>

<p>No problems and we can see it was a simple fast forward. Now to merge in John&#8217;s work (&#8216;origin/master&#8217;).</p>

<pre><code>$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>

<p>Everything merged cleanly, so now Jessica&#8217;s history looks like this:</p>

<p>FIG: simpleb-3</p>

<p>Now &#8216;origin/master&#8217; is reachable from her &#8216;master&#8217; branch, so she should be able to successfully push (assuming John has not pushed again in the meantime).</p>

<pre><code>$ git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -&gt; master</code></pre>

<p>Now each developer has committed a few times and merged each others work successfully.</p>

<p>FIG: simpleb-4</p>

<p>So that is really one of the simplest workflows. You work for a while, generally in a topic branch, and merge into your master branch when it&#8217;s ready to be integrated. When you want to share that work, merge it into your own master branch, then fetch and merge &#8216;origin/master&#8217; if it has changed and finally push to the master branch on the server. The general sequence is something like:</p>

<p>FIG: sequence1</p>

<h3 id='private_managed_team'>Private Managed Team</h3>

<p>In this next scenario, we&#8217;ll look at contributor roles in a larger private group. Here we&#8217;ll look at how to work in an environment where small groups collaborate on features and then those team based contributions are integrated by a another party.</p>

<p>Let&#8217;s say that John and Jessica are working together on one feature, while Jessica and Josie are working on a second. In this case the company is using a type of integration manager workflow where the work of the individual groups is integrated only by certain engineers and the master branch of the main repo can be updated only by those engineers. In this scenario, all work is done in team based branches and then pulled together by the integrators later.</p>

<p>Let&#8217;s follow Jessica&#8217;s workflow as she works on her two features, collaborating in parallel with two different developers in this environment. Assuming she already has her repository cloned, she decides to work on &#8216;featureA&#8217; first. She will create a new branch for the feature and do some work on it there.</p>

<pre><code># Jessica&#39;s Machine
$ git checkout -b featureA
Switched to a new branch &quot;featureA&quot;
$ vim lib/simplegit.rb
$ git commit -am &#39;add limit to log function&#39;
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>

<p>At this point she needs to share this with John, so she&#8217;ll push her featureA branch commits up to the server. Jessica does not have push access to the &#8216;master&#8217; branch, only the integrators do, so she&#8217;ll have to push to another branch in order to collaborate with John.</p>

<pre><code>$ git push origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -&gt; featureA</code></pre>

<p>Jessica now emails John to tell him that she pushed some work into a branch named &#8216;featureA&#8217; and he can look at it now. While she waits for feedback from John, Jessica decides to start working on &#8216;featureB&#8217; with Josie. To begin, she starts a new feature branch, basing it off the server&#8217;s &#8216;master&#8217; branch.</p>

<pre><code># Jessica&#39;s Machine
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch &quot;featureB&quot;</code></pre>

<p>Now Jessica makes a couple of commits on the &#8216;featureB&#8217; branch.</p>

<pre><code>$ vim lib/simplegit.rb
$ git commit -am &#39;made the ls-tree function recursive&#39;
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am &#39;add ls-files&#39;
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)</code></pre>

<p>Jessica&#8217;s repository looks like this now:</p>

<pre><code>FIG: simplec-1</code></pre>

<p>Now she&#8217;s ready to push her work up, but gets an email from Josie that a branch with some initial work on it was already pushed to the server as &#8216;featureBee&#8217;. Jessica will first need to merge those changes in with her own before she can push to the server. She can then fetch Josie&#8217;s changes down with &#8216;git fetch&#8217;:</p>

<pre><code>$ git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -&gt; origin/featureBee</code></pre>

<p>Jessica can now merge this into the work she did with &#8216;git merge&#8217;:</p>

<pre><code>$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)</code></pre>

<p>Now there is a bit of a problem - she needs to push the merged work in her &#8216;featureB&#8217; branch to the &#8216;featureBee&#8217; branch on the server. That can be done by specifying the local branch followed by a &#8217;:&#8217; followed by the remote branch to the &#8216;git push&#8217; command.</p>

<pre><code>$ git push origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -&gt; featureBee</code></pre>

<p>This is called a &#8216;refspec&#8217; - see Chapter 9 for more detailed discussion of Git refspecs and different things that you can do with them.</p>

<p>Now John emails Jessica to say he&#8217;s pushed some changes to the &#8216;featureA&#8217; branch and asks her to verify them. She can simply run a &#8216;git fetch&#8217; to pull down those changes.</p>

<pre><code>$ git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -&gt; origin/featureA</code></pre>

<p>Then she can see what has been changed with <code>git log</code>.</p>

<pre><code>$ git log origin/featureA ^featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25</code></pre>

<p>Finally, she merges John&#8217;s work into her own &#8216;featureA&#8217; branch.</p>

<pre><code>$ git checkout featureA
Switched to branch &quot;featureA&quot;
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)</code></pre>

<p>Jessica wants to tweak something, so she commits again and then pushes this back up to the server.</p>

<pre><code>$ git commit -am &#39;small tweak&#39;
[featureA ed774b3] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)	
$ git push origin featureA
...
To jessica@githost:simplegit.git
   3300904..ed774b3  featureA -&gt; featureA</code></pre>

<p>Jessica&#8217;s commit history now looks something like this:</p>

<p>FIG: simplec-2</p>

<p>Now Jessica, Josie and John inform the integrators that the &#8216;featureA&#8217; and &#8216;featureBee&#8217; branches on the server are ready for integration into the mainline. Once they integrate these branches into the mainline, a fetch will bring down the new merge commits.</p>

<p>FIG: simplec-3</p>

<p>Many groups switch to Git because of this ability to have multiple teams working in parallel, merging the different lines of work late in the process. The ability for smaller subgroups of a team to collaborate together via remote branches without neccesarily having to involve or impede the entire team is a huge benefit of Git.</p>

<p>The sequence for the workflow we saw here was something like this:</p>

<p>FIG: sequence2</p>

<h3 id='public_small_project'>Public Small Project</h3>

<p>Contributing to public projects is a bit different. Since you don&#8217;t have the permissions to directly update branches on their project, you have to get the work to the maintainers somehow else. This first example will describe contributing via forking on Git hosts that support easy forking. The repo.or.cz and GitHub hosting sites both support this and many project maintainers may expect this style of contribution. In the next section we&#8217;ll deal with projects that prefer to accept contributed patches via email.</p>

<p>First, you&#8217;ll probably want to clone the main repository, create a topic branch for the patch or patch series you are planning to contribute and do your work there. The sequence will look basically like this:</p>

<pre><code>$ git clone (url)
$ cd project
$ git checkout -b featureA
$ (work)
$ git commit
$ (work)
$ git commit</code></pre>

<p>You may want to use <code>rebase -i</code> here to squash your work down to a single commit, or rearrange the work in the commits to make the patch easier for the maintainer to review - see Chapter 6 for more information on interactive rebasing.</p>

<p>When your branch work is finished and you are ready to contribute it back to the maintainers, go to the original project page and click the &#8216;fork&#8217; button, creating your own writable fork of the project. You then need to add this new repository URL in as a second remote, we&#8217;ll name it &#8216;myfork&#8217;.</p>

<pre><code>$ git remote add myfork (url)</code></pre>

<p>Now we want to push our work up to it. It&#8217;s probably easiest to simply push the remote branch you&#8217;re working on up to your repository, rather than merging into your master branch and pushing that up. The reason for this is that if the work is not accepted or is cherry picked, you don&#8217;t have to rewind your master branch. If the maintainers merge, rebase or cherry-pick your work, you will get it back via pulling from their repository eventually anyhow.</p>

<pre><code>$ git push myfork featureA</code></pre>

<p>Now that your work has been pushed up to your fork, you need to notify the maintainer. This is often called a &#8216;pull request&#8217; and you can either generate it via the website itself - GitHub has a &#8216;pull request&#8217; button that will automatically message the maintainer - or you can run the <code>git request-pull</code> command and email the output to the project maintainer manually.</p>

<p>The request-pull command takes the base branch that you want your topic branch pulled into and the Git repository url you want them to pull from and will output a nice summary of all the changes you are asking them to pull in. For instance, if Jessica wanted to send John a pull request and she had done two commits on the topic branch she just pushed up, she could run this:</p>

<pre><code>$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
  John Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)</code></pre>

<p>sop: Yes, really, git request-pull knows how to expand a remote name to its URL.</p>

<p>Then the output of that can be sent to the maintainer - it tells them where the work was branched from, summarizes the commits and tells them where to pull this work from.</p>

<p>On a project that you&#8217;re not the maintainer for, it&#8217;s generally easier to have a branch like &#8216;master&#8217; always be tracking &#8216;origin/master&#8217; and to do your work in topic branches that you can easily discard if they are rejected, or rebased if the tip has moved and they no longer apply cleanly. For example, if you wanted to submit a second topic of work to the project, do not continue working on the topic branch you just pushed up - start over from the main repository&#8217;s master branch.</p>

<pre><code>$ git fetch origin
$ git checkout -b featureB origin/master
$ (work)
$ git commit
$ git push myfork featureB
$ (email maintainer)</code></pre>

<p>Now each of your topics are contained within silos - similar to patch queues - that you can rewrite, rebase and modify without interfering or interdepending on each other.</p>

<p>FIG: simpled-1</p>

<p>sop: Given the fetch that started the sequence, shouldn&#8217;t branch featureB be based on commit 33009 in this diagram? Move the fetch to after the push, then you can keep the diagram (and your later example) as-is.</p>

<p>Let&#8217;s say that the project maintainer has pulled in a bunch of other patches and tried your first branch, but it no longer cleanly merges. In this case we can try to rebase that branch on top of origin/master, resolve the conflicts for the maintainer, and then resubmit our changes.</p>

<pre><code>$ git checkout featureA
$ git rebase origin/master
$ git push myfork +featureA</code></pre>

<p>FIG simpled-2</p>

<p>sop: Explain why I had to add the + in front of featureA there (force push due to rewind).</p>

<p>Let&#8217;s look at one more possible scenario - the maintainer has looked at work in your second branch and likes the concept but would like an implementation detail changed. We will take this opportunity to move the work to be based off the current project&#8217;s master branch, too. We will start a new branch based off the current &#8216;origin/master&#8217; branch, squash the &#8216;featureB&#8217; changes there, resolve any conflicts, make the implementation change and then push that up as a new branch.</p>

<pre><code>$ git checkout -b featureBv2 origin/master
$ git merge --no-commit --squash featureB
$ (change implementation)
$ git commit
$ git push myfork featureBv2</code></pre>

<p>The <code>--squash</code> option means that it will take all the work on the merged branch and squash it into one non-merge commit on top of the branch you&#8217;re on. The <code>--no-commit</code> option tells Git not to automatically record a commit. This allows us to introduce all the changes from another branch and then make some more changes before recording the new commit.</p>

<p>Now you can send the maintainer a message that you&#8217;ve made the requested changes and they can find them in your &#8216;topicBv2&#8217; branch.</p>

<p>FIG simpled-3</p>

<h3 id='public_large_project'>Public Large Project</h3>

<p>Many larger projects have established procedures for accepting patches - you&#8217;ll need to check the specific rules for each project as they will differ a little. However, many larger public projects accept patches via a developer mailing list, so we&#8217;ll go over an example of that now.</p>

<p>The workflow itself is very similar to the previous use case - create topic branches for each patch series you work on - the difference is how you submit them to the project. Instead of forking the project and pushing to your own writable version, we&#8217;re going to generate email versions of each commit series and email them to the developer mailing list.</p>

<pre><code>$ git checkout -b topicA
$ (work)
$ git commit
$ (work)
$ git commit</code></pre>

<p>Now we have two commits that we want to send to the mailing list. We will use <code>git format-patch</code> to generate the mbox formatted files that we can email to the list - it turns each commit into an email message with the first line of the commit message as the subject and the rest of the message plus the patch that the commit introduces as the body. The nice thing about this is that applying a patch from an email generated with <code>format-patch</code> will preserve all the commit information properly, as we&#8217;ll see more of in the next section where we apply these commits.</p>

<pre><code>$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch</code></pre>

<p>The <code>format-patch</code> command will print out the names of the patch files that it created. The <code>-M</code> switch tells Git to look for renames. The files end up looking like this:</p>

<pre><code>$ cat 0001-add-limit-to-log-function.patch 
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = &#39;master&#39;)
-    command(&quot;git log #{treeish}&quot;)
+    command(&quot;git log -n 20 #{treeish}&quot;)
   end

   def ls_tree(treeish = &#39;master&#39;)
-- 
1.6.2.rc1.20.g8c5b.dirty</code></pre>

<p>You can also edit these patch files to add more information for the email list that you don&#8217;t want to show up in the commit message. If you add text between the &#8217;&#8212;&#8217; line and the beginning of the patch (the &#8216;lib/simplegit.rb&#8217; line) then developers can read it, but applying the patch will exclude it.</p>

<p>Now, to email this to a mailing list, you can either paste the file into your email program or send it via a command line program. Pasting the text often causes formatting issues, especially with &#8220;smarter&#8221; clients that don&#8217;t preserve newlines and other whitespace appropriately. Luckily, Git provides a tool to help send properly formatted patches via IMAP, which may be a bit easier for you. Here I&#8217;ll demonstrate how to send a patch via Gmail, which happens to be the email agent that I use, though you can read detailed instructions for a number of mail programs at the end of the afore mentioned <code>Documentation/SubmittingPatches</code> file in the Git source code.</p>

<p>First you need to setup the &#8216;imap&#8217; section in your ~/.gitconfig file. You can set each value seperately with a series of <code>git config</code> commands or you can add them manually, but in the end your config file should look something like this:</p>

<pre><code>[imap]
  folder = &quot;[Gmail]/Drafts&quot;
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = p4ssw0rd
  port = 993
  sslverify = false</code></pre>

<p>If your IMAP server does not use SSL, the last two lines are probably not neccesary and the host value will be &#8216;imap://&#8217; instead of &#8216;imaps://&#8217;.</p>

<p>When that is setup, you can then use <code>git send-email</code> to place the patch series in the Drafts folder of the specified IMAP server.</p>

<pre><code>$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith &lt;jessica@example.com&gt;] 
Emails will be sent from: Jessica Smith &lt;jessica@example.com&gt;
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y</code></pre>

<p>Then it will spit out a bunch of log information looking something like this for each patch you are sending.</p>

<pre><code>(mbox) Adding cc: Jessica Smith &lt;jessica@example.com&gt; from line &#39;From: Jessica Smith &lt;jessica@example.com&gt;&#39;
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith &lt;jessica@example.com&gt;
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: &lt;1243715356-61726-1-git-send-email-jessica@example.com&gt;
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: &lt;y&gt;
References: &lt;y&gt;

Result: OK</code></pre>

<p>At this point, you should be able to go to your Drafts folder, change the To field to be the mailing list your sending the patch to, possibly CC the maintainer or person responsible for that section and then send it off.</p>

<h3 id='summary'>Summary</h3>

<p>In this section we&#8217;ve covered a number of common workflows for dealing with several very different types of Git projects you&#8217;re likely to encounter and introduced a couple of new tools to help you manage this process. Next we&#8217;ll see how to work the other side of the coin, maintaining a Git project - how to be a benevolent dictator or integration manager.</p>

<div id='nav'>
<a href='ch5-0.html'>prev</a> | <a href='ch5-2.html'>next</a>
</div>