---
layout: translation
title: Pro Git 7.2 Git のカスタマイズ Git の属性
---
<h2 id='git_'>Git の属性</h2>

<p>設定項目の中には、パスにも指定できるものがあります。Git はその設定を、指定したパスのサブディレクトリやファイルにのみ適用するのです。これらのパス固有の設定は Git の属性と呼ばれ、あるディレクトリ (通常はプロジェクトのルートディレクトリ) の直下の <code>.gitattributes</code> か、あるいはそのファイルをプロジェクトとともにコミットしたくない場合は <code>.git/info/attributes</code> に設定します。</p>

<p>属性を使うと、ファイルやディレクトリ単位で個別のマージ戦略を指定したりテキストファイル以外での diff の取得方法を指示したり、あるいはチェックインやチェックアウトの前に Git にフィルタリングさせたりすることができます。このセクションでは、Git プロジェクトでパスに設定できる属性のいくつかについて学び、実際にその機能を使う例を見ていきます。</p>

<h3 id='id151'>バイナリファイル</h3>

<p>Git の属性を使ってできるちょっとした技として、どのファイルがバイナリファイルなのかを (その他の方法で判別できない場合のために) 指定して Git に対してバイナリファイルの扱い方を指示するというものがあります。たとえば、機械で生成したテキストファイルの中には diff が取得できないものがありますし、バイナリファイルであっても diff が取得できるものもあります。それを Git に指示する方法を紹介します。</p>

<h4 id='id152'>バイナリファイルの特定</h4>

<p>テキストファイルのように見えるファイルであっても、何らかの目的のために意図的にバイナリデータとして扱いたいこともあります。たとえば、Mac の Xcode プロジェクトの中には <code>.pbxproj</code> で終わる名前のファイルがあります。これは JSON (プレーンテキスト形式の javascript のデータフォーマット) のデータセットで、IDE がビルド設定などをディスクに書き出したものです。すべて ASCII で構成されるので、理論上はこれはテキストファイルです。しかしこのファイルをテキストファイルとして扱いたくはありません。実際のところ、このファイルは軽量なデータベースとして使われているからです。他の人が変更した内容をマージすることはできませんし、diff をとってもあまり意味がありません。このファイルは、基本的に機械が処理するものなのです。要するに、バイナリファイルと同じように扱いたいということです。</p>

<p>すべての <code>pbxproj</code> ファイルをバイナリデータとして扱うよう Git に指定するには、次の行を <code>.gitattributes</code> ファイルに追加します。</p>

<pre><code>*.pbxproj -crlf -diff</code></pre>

<p>これで、Git が CRLF 問題の対応をすることもなくなりますし、git show や git diff を実行したときにもこのファイルの diff を調べることはなくなります。Git 1.6 系では、次のようなマクロを使うこともできます。これは <code>-crlf -diff</code> と同じ意味です。</p>

<pre><code>*.pbxproj binary</code></pre>

<h4 id='id153'>バイナリファイルの差分</h4>

<p>Git 1.6系では、バイナリファイルの差分を効果的に扱うためにGitの属性機能を使うことができます。通常のdiff機能を使って比較を行うことができるように、バイナリデータをテキストデータに変換する方法をGitに教えればいいのです。</p>

<p>これは素晴らしい機能ですがほとんど知られていないので、少し例をあげてみたいと思います。あなたはまず最初に人類にとっても最も厄介な問題のひとつを解決するためにこのテクニックを使いたいと思うでしょう。そう、Wordで作成した文書のバージョン管理です。奇妙なことに、Wordは最も恐ろしいエディタだと全ての人が知ってるいるにも係わらず、全ての人がWordを使っています。Word文書をバージョン管理したいと思ったなら、Gitのリポジトリにそれらを追加して、まとめてcommitすればいいのです。しかし、それでいいのでしょうか？ あなたが&#8217;git diff&#8217;をいつも通りに実行すると、次のように表示されるだけです。</p>

<pre><code>$ git diff 
diff --git a/chapter1.doc b/chapter1.doc
index 88839c4..4afcb7c 100644
Binary files a/chapter1.doc and b/chapter1.doc differ</code></pre>

<p>これでは2つのバージョンをcheckoutしてそれらを自分で見比べてみない限り、比較することは出来ませんよね？ Gitの属性を使えば、うまく解決できます。<code>.gitattributes</code>に次の行を追加して下さい。</p>

<pre><code>*.doc diff=word</code></pre>

<p>これは、指定したパターン(.doc)にマッチした全てのファイルに対して、差分を表示する時には&#8221;word&#8221;というフィルタを使うべきであるとGitに教えているのです。&#8221;word&#8221;フィルタとは何でしょうか？ それはあなたが用意しなければなりません。Word文書をテキストファイルに変換するプログラムとして <code>strings</code> を使うように次のようにGitを設定してみましょう。</p>

<pre><code>$ git config diff.word.textconv strings</code></pre>

<p>これで、<code>.doc</code>という拡張子をもったファイルはそれぞれのファイルに<code>strings</code>というプログラムとして定義された&#8221;word&#8221;フィルタを通してからdiffを取るべきだということをGitは知っていることになります。こうすることで、Wordファイルに対して直接差分を取るのではなく、より効果的なテキストベースでの差分を取ることができるようになります。</p>

<p>例を示しましょう。この本の第1章をGitリポジトリに登録した後、ある段落にいくつかの文章を追加して保存し、それから、変更箇所を確認するために<code>git diff</code>を実行しました。</p>

<pre><code>$ git diff
diff --git a/chapter1.doc b/chapter1.doc
index c1c8a0a..b93c9e4 100644
--- a/chapter1.doc
+++ b/chapter1.doc
@@ -8,7 +8,8 @@ re going to cover Version Control Systems (VCS) and Git basics
 re going to cover how to get it and set it up for the first time if you don
 t already have it on your system.
 In Chapter Two we will go over basic Git usage - how to use Git for the 80% 
-s going on, modify stuff and contribute changes. If the book spontaneously 
+s going on, modify stuff and contribute changes. If the book spontaneously 
+Let&#39;s see if this works.</code></pre>

<p>Gitは正しく、追加した&#8221;Let’s see if this works&#8221;という文字列を首尾よく、かつ、簡潔に知らせてくれました。予想外の差分が表示されているので、完璧といえません。しかし、正しく動作しているとはいえます。あなたがWord文書をテキストファイルに変換するもっと良いプログラムを見付けられれば、よりよい結果を得られるでしょう。とはいえ、<code>strings</code>はほとんどのMacとLinuxで動作するので、様々なバイナリフォーマットに試してみるのに、最初の選択肢としては良いと思います。</p>

<p>その他の興味深い問題としては画像ファイルの差分があります。JPEGファイルに対するひとつの方法としては、EXFI情報(多くのファイルでメタデータとして使われています)を抽出するフィルタを使う方法です。<code>exiftool</code>をダウンロードしインストールすれば、画像データをメタデータの形でテキストデータとして扱うことができます。従って、次のように設定すれば、画像データの差分をメタデータの差分という形で表示することができます。</p>

<pre><code>$ echo &#39;*.png diff=exif&#39; &gt;&gt; .gitattributes
$ git config diff.exif.textconv exiftool</code></pre>

<p>上記の設定をしてからプロジェクトで画像データを置き換えて<code>git diff</code>と実行すれば、次のように表示されることになるでしょう。</p>

<pre><code>diff --git a/image.png b/image.png
index 88839c4..4afcb7c 100644
--- a/image.png
+++ b/image.png
@@ -1,12 +1,12 @@
 ExifTool Version Number         : 7.74
-File Size                       : 70 kB
-File Modification Date/Time     : 2009:04:21 07:02:45-07:00
+File Size                       : 94 kB
+File Modification Date/Time     : 2009:04:21 07:02:43-07:00
 File Type                       : PNG
 MIME Type                       : image/png
-Image Width                     : 1058
-Image Height                    : 889
+Image Width                     : 1056
+Image Height                    : 827
 Bit Depth                       : 8
 Color Type                      : RGB with Alpha</code></pre>

<p>ファイルのサイズと画像のサイズが変更されたことが簡単に見て取れるでしょう。</p>

<h3 id='keyword_expansion'>Keyword Expansion</h3>

<p>SVN- or CVS-style keyword expansion is often requested by developers used to those systems. The main problem with this in Git is that you can’t modify a file with information about the commit after you’ve committed, because Git checksums the file first. However, you can inject text into a file when it’s checked out and remove it again before it’s added to a commit. Git attributes offers you two ways to do this.</p>

<p>First, you can inject the SHA-1 checksum of a blob into an <code>$Id$</code> field in the file automatically. If you set this attribute on a file or set of files, then the next time you check out that branch, Git will replace that field with the SHA-1 of the blob. It’s important to notice that it isn’t the SHA of the commit, but of the blob itself:</p>

<pre><code>$ echo &#39;*.txt ident&#39; &gt;&gt; .gitattributes
$ echo &#39;$Id$&#39; &gt; test.txt</code></pre>

<p>The next time you check out this file, Git injects the SHA of the blob:</p>

<pre><code>$ rm text.txt
$ git checkout -- text.txt
$ cat test.txt 
$Id: 42812b7653c7b88933f8a9d6cad0ca16714b9bb3 $</code></pre>

<p>However, that result is of limited use. If you’ve used keyword substitution in CVS or Subversion, you can include a datestamp — the SHA isn’t all that helpful, because it’s fairly random and you can’t tell if one SHA is older or newer than another.</p>

<p>It turns out that you can write your own filters for doing substitutions in files on commit/checkout. These are the &#8220;clean&#8221; and &#8220;smudge&#8221; filters. In the <code>.gitattributes</code> file, you can set a filter for particular paths and then set up scripts that will process files just before they’re committed (&#8220;clean&#8221;, see Figure 7-2) and just before they’re checked out (&#8220;smudge&#8221;, see Figure 7-3). These filters can be set to do all sorts of fun things.</p>

<p><center><img src="/figures/ch7/18333fig0702-tn.png"></center><br/> Figure 7-2. The “smudge” filter is run on checkout.</p>

<p><center><img src="/figures/ch7/18333fig0703-tn.png"></center><br/> Figure 7-3. The “clean” filter is run when files are staged.</p>

<p>The original commit message for this functionality gives a simple example of running all your C source code through the <code>indent</code> program before committing. You can set it up by setting the filter attribute in your <code>.gitattributes</code> file to filter <code>*.c</code> files with the &#8220;indent&#8221; filter:</p>

<pre><code>*.c     filter=indent</code></pre>

<p>Then, tell Git what the &#8220;indent&#8221;&#8221; filter does on smudge and clean:</p>

<pre><code>$ git config --global filter.indent.clean indent
$ git config --global filter.indent.smudge cat</code></pre>

<p>In this case, when you commit files that match <code>*.c</code>, Git will run them through the indent program before it commits them and then run them through the <code>cat</code> program before it checks them back out onto disk. The <code>cat</code> program is basically a no-op: it spits out the same data that it gets in. This combination effectively filters all C source code files through <code>indent</code> before committing.</p>

<p>Another interesting example gets <code>$Date$</code> keyword expansion, RCS style. To do this properly, you need a small script that takes a filename, figures out the last commit date for this project, and inserts the date into the file. Here is a small Ruby script that does that:</p>

<pre><code>#! /usr/bin/env ruby
data = STDIN.read
last_date = `git log --pretty=format:&quot;%ad&quot; -1`
puts data.gsub(&#39;$Date$&#39;, &#39;$Date: &#39; + last_date.to_s + &#39;$&#39;)</code></pre>

<p>All the script does is get the latest commit date from the <code>git log</code> command, stick that into any <code>$Date$</code> strings it sees in stdin, and print the results — it should be simple to do in whatever language you’re most comfortable in. You can name this file <code>expand_date</code> and put it in your path. Now, you need to set up a filter in Git (call it <code>dater</code>) and tell it to use your <code>expand_date</code> filter to smudge the files on checkout. You’ll use a Perl expression to clean that up on commit:</p>

<pre><code>$ git config filter.dater.smudge expand_date
$ git config filter.dater.clean &#39;perl -pe &quot;s/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/&quot;&#39;</code></pre>

<p>This Perl snippet strips out anything it sees in a <code>$Date$</code> string, to get back to where you started. Now that your filter is ready, you can test it by setting up a file with your <code>$Date$</code> keyword and then setting up a Git attribute for that file that engages the new filter:</p>

<pre><code>$ echo &#39;# $Date$&#39; &gt; date_test.txt
$ echo &#39;date*.txt filter=dater&#39; &gt;&gt; .gitattributes</code></pre>

<p>If you commit those changes and check out the file again, you see the keyword properly substituted:</p>

<pre><code>$ git add date_test.txt .gitattributes
$ git commit -m &quot;Testing date expansion in Git&quot;
$ rm date_test.txt
$ git checkout date_test.txt
$ cat date_test.txt
# $Date: Tue Apr 21 07:26:52 2009 -0700$</code></pre>

<p>You can see how powerful this technique can be for customized applications. You have to be careful, though, because the <code>.gitattributes</code> file is committed and passed around with the project but the driver (in this case, <code>dater</code>) isn’t; so, it won’t work everywhere. When you design these filters, they should be able to fail gracefully and have the project still work properly.</p>

<h3 id='exporting_your_repository'>Exporting Your Repository</h3>

<p>Git attribute data also allows you to do some interesting things when exporting an archive of your project.</p>

<h4 id='exportignore'>export-ignore</h4>

<p>You can tell Git not to export certain files or directories when generating an archive. If there is a subdirectory or file that you don’t want to include in your archive file but that you do want checked into your project, you can determine those files via the <code>export-ignore</code> attribute.</p>

<p>For example, say you have some test files in a <code>test/</code> subdirectory, and it doesn’t make sense to include them in the tarball export of your project. You can add the following line to your Git attributes file:</p>

<pre><code>test/ export-ignore</code></pre>

<p>Now, when you run git archive to create a tarball of your project, that directory won’t be included in the archive.</p>

<h4 id='exportsubst'>export-subst</h4>

<p>Another thing you can do for your archives is some simple keyword substitution. Git lets you put the string <code>$Format:$</code> in any file with any of the <code>--pretty=format</code> formatting shortcodes, many of which you saw in Chapter 2. For instance, if you want to include a file named <code>LAST_COMMIT</code> in your project, and the last commit date was automatically injected into it when <code>git archive</code> ran, you can set up the file like this:</p>

<pre><code>$ echo &#39;Last commit date: $Format:%cd$&#39; &gt; LAST_COMMIT
$ echo &quot;LAST_COMMIT export-subst&quot; &gt;&gt; .gitattributes
$ git add LAST_COMMIT .gitattributes
$ git commit -am &#39;adding LAST_COMMIT file for archives&#39;</code></pre>

<p>When you run <code>git archive</code>, the contents of that file when people open the archive file will look like this:</p>

<pre><code>$ cat LAST_COMMIT
Last commit date: $Format:Tue Apr 21 08:38:48 2009 -0700$</code></pre>

<h3 id='merge_strategies'>Merge Strategies</h3>

<p>You can also use Git attributes to tell Git to use different merge strategies for specific files in your project. One very useful option is to tell Git to not try to merge specific files when they have conflicts, but rather to use your side of the merge over someone else’s.</p>

<p>This is helpful if a branch in your project has diverged or is specialized, but you want to be able to merge changes back in from it, and you want to ignore certain files. Say you have a database settings file called database.xml that is different in two branches, and you want to merge in your other branch without messing up the database file. You can set up an attribute like this:</p>

<pre><code>database.xml merge=ours</code></pre>

<p>If you merge in the other branch, instead of having merge conflicts with the database.xml file, you see something like this:</p>

<pre><code>$ git merge topic
Auto-merging database.xml
Merge made by recursive.</code></pre>

<p>In this case, database.xml stays at whatever version you originally had.</p>

<div id='nav'>
<a href='ch7-1.html'>prev</a> | <a href='ch7-3.html'>next</a>
</div>