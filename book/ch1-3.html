---
layout: master
title: Pro Git 1.3 Introduction Git Basics
---
<h2 id='git_basics'>Git Basics</h2>

<p>So, what is Git in a nutshell? This is an important section to absorb because if you understand what Git is and how it works fundamentally, then using Git effectively will probably be much easier for you. One of the first things you should try to do as you learn Git is to attempt to clear your mind of the things you know about other VCSs you may be familiar with, such as Subversion or Perforce. The main reason for this is that it can lead to some subtle confusion when using the tool. The way Git stores and thinks about information is much different than these other systems and understanding what those differences are will likely help you to not become confused while using it.</p>

<h3 id='snapshots_not_differences'>Snapshots, not Differences</h3>

<p>The major difference between Git and basically any other VCS (Subversion and friends included) is the way Git thinks about its data. For most other systems, the information stored is conceptually a list of file based changes. These systems (CVS, Subversion, Perforce, Mercurial, Bazaar, etc) all think of the information they keep as a set of files and the changes that were made to each file over time.</p>

<p><img src='/images/fig14.png' alt='Figure 1.4' /> <em>Figure 1.4 - Other systems tend to store data as changes to a base version</em></p>

<p>** TODO : FIX FIGURE (Time Axis, Rev1, Rev2) **</p>

<p>Git does not think of nor store its data this way. Instead, Git thinks of its data more like a set of snapshots of a mini filesystem. Every time you &#8216;commit&#8217;, or save the state of your project in Git, what it basically does is take a picture of what all of your files look like at that moment and store a reference to it. To be efficient, if files have not changed, it doesn&#8217;t store the file again, just a link to the previous identical file it has already stored.</p>

<p><img src='/images/fig15.png' alt='Figure 1.5' /> <em>Figure 1.5 - Git stores data as snapshots of the project over time</em></p>

<p>** TODO : FIX FIGURE (Time Axis, Rev1, Rev2) **</p>

<p>This is an important distinction between Git and nearly everything else. It makes Git reconsider nearly every aspect of version control that most other systems generally copied from the previous generation. This makes Git itself almost more like a mini filesystem with some incredibly powerful tools built on top of it, rather than simply a VCS. We&#8217;ll explore some of the incredible benefits we gain by thinking of our data this way when we cover Git branching in Chapter 3.</p>

<h3 id='nearly_every_operation_is_local'>Nearly Every Operation is Local</h3>

<p>If you are used to a centralized VCS system, this aspect of Git is going to make you think that the gods of speed have blessed Git with unworldly powers. Since you have the entire history of the project right there on your local disk, most operations will seem almost instantaneous.</p>

<p>For example, in order to browse through the history of the project, Git does not need to go out to the server to get the history and display it for you – it simply reads it directly from your local database. This means it happens instantly. If you want to see the changes introduced between your current version of a file and the file a month ago, it can simply look up the file a month ago and do a local difference calculation, instead of having to either ask a remote server to do it or pull an older version of the file from the remote server in order to do it locally.</p>

<p>This also means that there is very little that you can&#8217;t do if you happen to be offline. If you get on an airplane or a train and want to do a little work, you can go ahead and commit happily until you get to a network connection to upload it. In many other systems this is either impossible or painful. In Perforce, for example, there is very little you can do when not connected to the server, and in Subversion and CVS you can edit files, but you cannot commit changes to your database (since your database is offline). This may not seem like a huge deal, but you might be surprised what a big difference this can make.</p>

<h3 id='git_has_integrity'>Git has Integrity</h3>

<p>Everything in Git is checksummed before it is stored and referred to by that checksum, meaning that it is impossible to change the contents of any file or directory without Git knowing about it. This is built into Git at the lowest levels and is integral to its philosophy. You can&#8217;t lose information in transit or get file corruption without Git being able to detect it.</p>

<p>The mechanism that Git uses for this checksumming is called a SHA-1 hash. This is a 40 character string composed of hexadecimal characters (0-9 and a-f) that is calculated based on the contents of a file or directory structure in Git. A SHA-1 hash looks something like this:</p>

<pre><code>24b9da6552252987aa493b52f8696cd6d3b00373</code></pre>

<p>You will see these hash values all over the place in Git because it uses them so much. In fact, everything that Git stores is not stored by file name, but is actually stored in the Git database addressable by the hash value of its contents.</p>

<h3 id='git_generally_only_adds_data'>Git Generally Only Adds Data</h3>

<p>When you do actions in Git, nearly all of them only add data to its database. It is very difficult to get the system to do anything that is undoable or make it erase data in any way. As in any version control system, you can lose or mess up changes you haven&#8217;t committed yet, but once you actually commit a snapshot into Git, you will basically always have it. Especially if you regularly push your database to another repository.</p>

<p>This has always made using Git a joy for me because I know that I can experiment without having the danger of severely screwing things up. For a more in-depth look at how Git stores its data and how you can recover things that seem to be lost, see “Under the Covers” in Chapter 9.</p>

<h3 id='the_three_states'>The Three States</h3>

<p>Alright, now pay attention. This is the main thing to remember about Git if you want the rest of your learning process to go smoothly. Git has three main states that your files can reside in. These states are <em>committed</em>, <em>modified</em>, and <em>staged</em>. <em>Committed</em> means that the data is safely stored in your local database. <em>Modified</em> means that you have changed the file but have not committed it to your database yet. <em>Staged</em> means that you have marked a modified file in its current version to go into your next commit snapshot.</p>

<p>This leads us to the three main sections of a Git project : the <em>Git Directory</em>, the <em>Working Directory</em> and the <em>Staging Area</em>.</p>

<p><img src='/images/fig16.png' alt='Figure 1.6' /> <em>Figure 1.6 - working directory, staging area and git directory</em></p>

<p>The Git Directory is where Git stores the metadata and object database for your project. This is the important part of Git and it is what is copied when you clone a repository from another computer.</p>

<p>The Working Directory is a single checkout of one version of the project. These files are pulled out of the compressed database in the Git Directory and placed on disk for you to use or modify.</p>

<p>The Staging Area is a simple file, generally contained in your Git Directory, that stores information about what is going to go into your next commit. This is sometimes referred to as the “Index”, but it is becoming fairly standard to refer to this in general as the Staging Area.</p>

<p>The basic Git workflow goes something like this:</p>

<ul>
<li>You modify files in your Working Directory</li>

<li>You stage the files, adding snapshots of them to your Staging Area</li>

<li>You do a commit, which takes the files in the Staging Area and stores that snapshot to your Git Directory permanently</li>
</ul>

<p>So, if a particular version of a file is in the Git Directory, it is considered committed, if it is modified but has been added to the staging area it is staged, and if it was changed since it was checked out but has not been staged it is simply modified. In Chapter 2 we&#8217;ll learn a bit more about these states and how you can either really take advantage of them, or skip the staged part entirely.</p>

<div id='nav'>
<a href='ch1-2.html'>prev</a> | <a href='ch1-4.html'>next</a>
</div>