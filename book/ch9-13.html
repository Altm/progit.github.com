---
layout: master
title: Pro Git 9.13 Git Internals Data Recovery
---
<h2 id='data_recovery'>Data Recovery</h2>

<p>At some point in your Git journey, you may accidentally lose a commit. Generally this happens because you force delete a branch that had work on it that it turns out you wanted after all, or you hard reset a branch abandoning commits that you actually wanted something from. Assuming this happens, how can you get your commits back?</p>

<p>Let&#8217;s see an example. We will hard reset our master branch in our test repository to an older commit and then recover the commits that we lost. First, let&#8217;s review where our repository is at this point:</p>

<pre><code>$ git log --pretty=oneline
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>

<p>Now let&#8217;s move our master branch back to the middle commit:</p>

<pre><code>$ git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9
HEAD is now at 1a410ef third commit
$ git log --pretty=oneline
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>

<p>OK, so now we&#8217;ve effectively lost the top two commits - we have no branch from which those commits are reachable. So, what we need to do is find the latest commit SHA and then add a branch that points to it. The trick is finding that latest commit SHA - it&#8217;s not like we&#8217;ve memorized it, right?</p>

<p>The quickest way is often using a tool called <code>git reflog</code>. As you are working, Git is silently recording what your HEAD is at everytime you change it. Every time you commit or change branches, the reflog is getting updated. You can see where you have been at any time by simply running <code>git reflog</code>.</p>

<pre><code>$ git reflog
1a410ef HEAD@{0}: 1a410efbd13591db07496601ebc7a059dd55cfe9: updating HEAD
ab1afef HEAD@{1}: ab1afef80fac8e34258ff41fc1b867c702daa24b: updating HEAD</code></pre>

<p>To inspect them, we&#8217;ll have to run <code>git show</code> on each SHA here, but it turns out that the bottom one is actually the commit that we lost, so we can recover that commit by running :</p>

<pre><code>$ git branch recover ab1afef
$ git log --pretty=oneline recover
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>

<p>DWP: So that has made us a new branch based called &#8216;recover&#8217; and with the head at ab1afe?</p>

<p>Now, let&#8217;s say our loss was for some reason not in the reflog - we can simulate that by expiring the reflog.</p>

<pre><code>$ git reset --hard 1a410e
$ rm -Rf .git/logs/</code></pre>

<p>Since the reflog data is kept in the &#8216;.git/logs/&#8217; directory, we now effectively have no reflog. So, how can we recover that commit at this point? One way is to use a utility called <code>git fsck</code> which checks your database for integrity. If we run it with the <code>--full</code> option, it will show us all objects that are not pointed to by another object.</p>

<pre><code>$ git fsck --full
dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4
dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b
dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9
dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293</code></pre>

<p>In this case we can see our missing commit there after &#8216;dangling commit&#8217;. At this point we could recover it the same way, by adding a branch that points to it.</p>

<div id='nav'>
<a href='ch9-12.html'>prev</a> | <a href='ch9-14.html'>next</a>
</div>