---
layout: master
title: Pro Git 6.4 Git Tools Rewriting History
---
<h2 id='rewriting_history'>Rewriting History</h2>

<p>There are many times when working with Git you may want to revise your commit history for some reason. One of the great things about Git is that it allows you to make decisions at the last possible moment. You can decide what files go into which commits right before you commit with the staging area, you can decide that you didn&#8217;t mean to be working on something yet with the stash command and you can rewrite commits that already happened so they look like they happened in a different way. This could be changing the order of the commits, changing messages or modifying files in a commit, squashing together or splitting apart commits or removing commits entirely - all before we share our work with others.</p>

<p>In this section we will cover how to accomplish these very useful tasks so that you can make your commit history look how you want it to look before you share it with others.</p>

<h3 id='changing_the_last_commit'>Changing the Last Commit</h3>

<p>Changing your last commit is probably the most common rewriting of history that you will do. There are two basic things you will want to do to your last commit - you will often just want to change the commit message, or you may want to change the snapshot you just recorded by adding, changing and removing files.</p>

<p>If you only want to modify your last commit message, it is very simple. Just run</p>

<pre><code>$ git commit --amend</code></pre>

<p>That will drop you into your text exitor which will have your last commit message in it that you can then edit. When you save and close the editor, it will write a new commit with that message in it and make it your new last commit.</p>

<p>If you have committed and then you want to change the snapshot you committed somehow by adding or changing files, it works basically the same way. If you stage the changes you want by editing a file and running <code>git add</code> on it or <code>git rm</code> to a tracked file, the subsequent <code>git commit --amend</code> will take your current staging area and make it the snapshot for the new commit.</p>

<p>You need to be careful with this because amending does change the SHA-1 of that commit - it is like a very small rebase, do not amend your last commit if you&#8217;ve already pushed it.</p>

<h3 id='changing_multiple_commit_messages'>Changing Multiple Commit Messages</h3>

<p>If you want to modify a commit that is farther back in your history, then we have to move to more complex tools. Git does not have a &#8216;modify history&#8217; tool, but we can sort of abuse the rebase tool to rebase a series of commits onto the head they were originally based on instead of moving them to another one. With the &#8216;interactive rebase&#8217; tool we can then stop after each commit we want to modify and change the message or add files or whatever we wish. You can run this with the -i option to git rebase. You will need to supply how far back you want to rewrite commits by telling it which commit to rebase onto.</p>

<p>For example, if you want to change the last 3 commit messages, or any of the commit messages in that group, you will have to supply as an argument to <code>git rebase -i</code> the parent of the last commit you want to edit, which would be <code>HEAD~2^</code> or <code>HEAD~3</code>. It may be easier to remember the <code>~3</code> since you&#8217;re trying to edit the last 3 commits, but keep in mind that you&#8217;re actually designating 4 commits ago, the parent of the last commit you want to edit.</p>

<pre><code>$ git rebase -i HEAD~3</code></pre>

<p>Remember again that this is a rebasing command - every commit that is included in this will be re-written, whether you change the message or not. Do not include any commit you have already pushed to a central server - it will mess other people up.</p>

<p>Running this command will give you a list of commits in your text editor that looks something like this:</p>

<pre><code>pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
#  p, pick = use commit
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#
# If you remove a line here THAT COMMIT WILL BE LOST.
# However, if you remove everything, the rebase will be aborted.
#</code></pre>

<p>Now, it&#8217;s important to note that these commits are listed in the opposite order then you normally see them using the <code>log</code> command. If we run a log, we&#8217;ll see something like this.</p>

<pre><code>$ git log --pretty=format:&quot;%h %s HEAD~3..HEAD&quot;
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit</code></pre>

<p>Notice that is in the reverse order. What the interactive rebase is doing is giving you a script that it&#8217;s going to run. It will start at the commit you specified on the command line (<code>HEAD~3</code>) and it will replay the changes introduced in each of these commits from top to bottom. Since it does that, it lists the oldest at the top, rather than the newest, since it is the first it will replay.</p>

<p>So, what we want to do is edit the script so that it stops at the commit we want to edit. To make the script stop after it applies a change, you need to edit the script. Change the word &#8216;pick&#8217; to the work &#8216;edit&#8217; for each of the commits you want the script to stop after. For example, let&#8217;s say we want to modify the third commit message only, we would change the file to look like this:</p>

<pre><code>edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file</code></pre>

<p>When you save and exit the editor, it will rewind you back to that last commit in that list and drop you on the command line with the following message:</p>

<pre><code>$ git rebase -i HEAD~3
Stopped at 7482e0d... updated the gemspec to hopefully work better
You can amend the commit now, with

	git commit --amend

Once you are satisfied with your changes, run

	git rebase --continue</code></pre>

<p>These instructions tell you exactly what to do. Type</p>

<pre><code>$ git commit --amend</code></pre>

<p>Change the commit message and exit the editor. Then run</p>

<pre><code>$ git rebase --continue</code></pre>

<p>This will try to apply the other two commits automatically and then you&#8217;re done. If you changed the &#8216;pick&#8217; to &#8216;edit&#8217; on more lines, you can repeat these steps for each commit you changed to &#8216;edit&#8217;. Each time it will stop and let you amend the commit and continue when you&#8217;re done.</p>

<h4 id='reordering_commits'>Reordering Commits</h4>

<p>You can also use interactive rebases to re-order or remove commits entirely. If you wanted to remove the &#8216;cat-file&#8217; commit and change the order that the other two commits were introduced, you would change the rebase script from this:</p>

<pre><code>pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file</code></pre>

<p>to this:</p>

<pre><code>pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit</code></pre>

<p>When you save and exit the editor, it will rewind your branch to the parent of these commits, then apply <code>310154e</code> and then <code>f7f3f6d</code> and then stop. You have effectively changed the order of those commits and removed the &#8216;cat-file&#8217; commit completely.</p>

<h4 id='squashing_a_commit'>Squashing a Commit</h4>

<p>It&#8217;s also possible to take a series of commits and squash them down into a single commit with the interactive rebasing tool. The script puts instructions in the rebase message that are very helpful.</p>

<pre><code>#
# Commands:
#  p, pick = use commit
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#
# If you remove a line here THAT COMMIT WILL BE LOST.
# However, if you remove everything, the rebase will be aborted.
#</code></pre>

<p>So, if instead of &#8216;pick&#8217; or &#8216;edit&#8217; you specify &#8216;squash&#8217;, Git will apply both that change and the change directly before it and make you merge the commit messages together. So, if we wanted to make a single commit from these three commits, we would make the script look like this:</p>

<pre><code>pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file</code></pre>

<p>When we save and exit the editor, Git will apply all three changes and then put us back into the editor to merge the three commit messages:</p>

<pre><code># This is a combination of 3 commits.
# The first commit&#39;s message is:
changed my name a bit

# This is the 2nd commit message:

updated README formatting and added blame

# This is the 3rd commit message:

added cat-file</code></pre>

<p>When we save that out, we&#8217;ll have a single commit that introduces the changes of all three previous commits.</p>

<h4 id='splitting_a_commit'>Splitting a Commit</h4>

<p>Splitting a commit is just undoing a commit and then partially staging and committing as many times as commits you want to end up with. For example, let&#8217;s say we want to split the middle commit of our 3 commits. Instead of &#8216;updated README formatting and added blame&#8217;, we want to split it into two commits - &#8216;updated README formatting&#8217; for the first, and &#8216;add blame&#8217; for the second. We can do that by changing the instruction on the commit we want to split up to &#8216;edit&#8217; in the <code>rebase -i</code> script.</p>

<pre><code>pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file</code></pre>

<p>Then when the script drops you to the command line, you reset that commit and then take the changes that have been reset and create multiple commits out of them. When you save and exit the editor, it will rewind to the parent of the first commit in your list, apply the first commit (<code>f7f3f6d</code>), apply the second (<code>310154e</code>) and then drop you to the console. There, you can do a mixed reset of that commit with <code>git reset HEAD^</code>, which will effectively undo that commit. Now you can stage and commit files until you have several commits and run <code>git rebase --continue</code> when you are done.</p>

<pre><code>$ git reset HEAD^
$ git add README
$ git commit -m &#39;updated README formatting&#39;
$ git add lib/simplegit.rb
$ git commit -m &#39;added blame&#39;
$ git rebase --continue</code></pre>

<p>Now Git will then apply the last commit (<code>a5f4a0d</code>) in the script and now you have a history that looks like this instead:</p>

<pre><code>$ git log -4 --pretty=format:&quot;%h %s&quot;
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit</code></pre>

<p>Once again, this changes the SHAs of all the commits in your list, so make sure that no commit shows up in that list that you have already pushed to a shared repository.</p>

<h3 id='the_nuclear_option__filterbranch'>The Nuclear Option : filter-branch</h3>

<p>There is another history rewriting option which you would use if you need to rewrite a larger number of commits in some scriptable way. For instance, change your email address globally, or remove a file from every commit. The command is <code>filter-branch</code> and it can rewrite huge swaths of your history, so it probably shouldn&#8217;t be used unless your project is not yet public or has otherwise not had other people base work off the commits you&#8217;re about to rewrite. However, it can be very useful and we&#8217;ll just cover a few of the common uses so you can get an idea of some of the things it&#8217;s capable of.</p>

<h4 id='removing_a_file_from_every_commit'>Removing a File from Every Commit</h4>

<p>This occurs fairly commonly. Someone accidentally commits a huge binary file with a thoughtless <code>git add .</code> and you want to remove it everywhere. Perhaps you accidentally committed a file that had a password in it and you want to make your project open source. <code>filter-branch</code> is the tool you&#8217;ll probably want to use in order to scrub your entire history. To remove a file named passwords.txt from your entire history, you can use the <code>--tree-filter</code> option to filter-branch.</p>

<pre><code>$ git filter-branch --tree-filter &#39;rm -f passwords.txt&#39; HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref &#39;refs/heads/master&#39; was rewritten</code></pre>

<p>The <code>--tree-filter</code> option will run the specified command on after each checkout of the project and then re-commit the results. In this case, I&#8217;m removing a file called &#8216;passwords.txt&#8217; from every snapshot, whether it exists or not. If I wanted to remove all accidentally committed editor backup files I might run something like <code>git filter-branch --tree-filter &#39;rm -f *~&#39; HEAD</code>.</p>

<p>You will be able to watch it rewriting trees and commits and then move the branch pointer at the end. It is generally a good idea to do this in a testing branch and then hard reset your master branch after you&#8217;ve determined the outcome is what you really want. If you want to run it on all of your branches, you can pass <code>--all</code> to the command.</p>

<h4 id='making_a_subdirectory_the_new_root'>Making a Subdirectory the new Root</h4>

<p>If you&#8217;ve done an import from another source control system and have subdirectories that simply make no sense (&#8216;trunk&#8217;, &#8216;tags&#8217;, etc) and you want to make the &#8216;trunk&#8217; subdirectory be the new project root for every commit, <code>filter-branch</code> can help you do that too.</p>

<pre><code>$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref &#39;refs/heads/master&#39; was rewritten</code></pre>

<p>Now our new project root is what was in the &#8216;trunk&#8217; subdirectory each time. It will also remove commits that did not effect that subdirectory automatically.</p>

<h4 id='changing_email_addresses_globally'>Changing Email Addresses Globally</h4>

<p>Another common case is that you forgot to run <code>git config</code> to set your name and email address before you started working, or perhaps you want to open source a project at work and want to change all your work email addresses to your personal one. In any case, changing email addresses in multiple commits in a batch is done with <code>filter-branch</code> as well. You want to be careful to only change the email addresses that are yours, so we&#8217;ll use a <code>--commit-filter</code> for this.</p>

<pre><code>$ git filter-branch --commit-filter &#39;
        if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;schacon@localhost&quot; ];
        then
                GIT_AUTHOR_NAME=&quot;Scott Chacon&quot;;
                GIT_AUTHOR_EMAIL=&quot;schacon@example.com&quot;;
                git commit-tree &quot;$@&quot;;
        else
                git commit-tree &quot;$@&quot;;
        fi&#39; HEAD</code></pre>

<p>This will go through and rewrite every commit to have your new address. Since commits contain the SHA-1 values of their parents, this will basically change every commit SHA in your history, not just the ones that have the matching email address.## Debugging with Git ##</p>

<p>Git also provides a couple of tools to help you debug issues in your project. Since Git is designed to work with nearly any type of project, these tools are pretty generic, but can often be really helpful in hunting down a bug or culprit when things go wrong.</p>

<h3 id='file_annotation'>File Annotation</h3>

<p>If you track down a bug in your code and you want to know when it was introduced and why, file annotation is often your best tool. This will show you what commit was the last to modify each line of any file. So, if you see that a method in your code is buggy, you&#8217;ll want to annotate the file with <code>git blame</code> to see when it was done. In this example, we&#8217;re going to use the <code>-L</code> option to limit the output to just lines 12 thorugh 22.</p>

<pre><code>$ git blame -L 12,22 simplegit.rb 
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 12)   def show(treeish = &#39;master&#39;)
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 13)     command(&quot;git show #{treeish}&quot;)
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 14)   end
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 15) 
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 16)   def log(treeish = &#39;master&#39;)
79eaf55d (Scott Chacon  2008-04-06 10:15:08 -0700 17)     command(&quot;git log -n 25 #{treeish}&quot;)
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 18)   end
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 19) 
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 20)   def blame(path)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 21)     command(&quot;git blame #{path}&quot;)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 22)   end</code></pre>

<p>The first thing to notice is that the first field is the partial SHA-1 of the commit that last modified that line. The next two fields are values extracted from that commit, the author name and the authored date of that commit, so you can easily see who and when that line was modified. After that is the line number and the actual content of the file. Also to note is the <code>^4832fe2</code> commit lines, which designates that those lines were in the original commit of this file. That commit is when this file was first added to this project and those lines have been unchanged since. This is a tad confusing, since now we&#8217;ve seen at least three different ways that Git uses the &#8217;^&#8217; to modify a commit SHA, but that is what it means here.</p>

<p>One of the other cool things about Git is that it does not track file renames explicitly. It simply records the snapshots and then tries to figure out what was renamed implicitly, after the fact. One of the interesting features of this is that you can ask it to figure out all sorts of code movement as well. If you pass a <code>-C</code> to <code>git blame</code>, Git will analyze the file you&#8217;re annotating and try to figure out where snippets of code within it originally came from if they were copied from elsewhere. Recently I was refactoring a file named GITServerHandler.m into multiple files, one of them was GITPackUpload.m. If I blame GITPackUpload.m with the <code>-C</code> option, I can actually see where sections of the code originally came from.</p>

<pre><code>$ git blame -C -L 141,153 GITPackUpload.m 
f344f58d GITServerHandler.m (Scott Chacon 2009-01-04 18:59:04 -0800 141) 
f344f58d GITServerHandler.m (Scott Chacon 2009-01-04 18:59:04 -0800 142) - (void) gatherObjectShasFromC
f344f58d GITServerHandler.m (Scott Chacon 2009-01-04 18:59:04 -0800 143) {
70befddd GITServerHandler.m (Scott Chacon 2009-03-22 20:02:27 -0700 144)         //NSLog(@&quot;GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott Chacon 2009-03-24 18:32:50 +0100 145)         
ad11ac80 GITPackUpload.m    (Scott Chacon 2009-03-24 18:32:50 +0100 146)         NSString *parentSha;
ad11ac80 GITPackUpload.m    (Scott Chacon 2009-03-24 18:32:50 +0100 147)         GITCommit *commit = [g
ad11ac80 GITPackUpload.m    (Scott Chacon 2009-03-24 18:32:50 +0100 148)         
ad11ac80 GITPackUpload.m    (Scott Chacon 2009-03-24 18:32:50 +0100 149)         //NSLog(@&quot;GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott Chacon 2009-03-24 18:32:50 +0100 150)         
56ef2caf GITServerHandler.m (Scott Chacon 2009-01-05 21:44:26 -0800 151)         if(commit) {
56ef2caf GITServerHandler.m (Scott Chacon 2009-01-05 21:44:26 -0800 152)                 [refDict setOb
56ef2caf GITServerHandler.m (Scott Chacon 2009-01-05 21:44:26 -0800 153)                 </code></pre>

<p>This is really useful, because normally you would get as the original commit the commit where you copied the code over because that is the first time you touched those lines in this file. Git will tell you the original commit where you wrote those lines, even if it was in another file.</p>

<h3 id='binary_search'>Binary Search</h3>

<p>Annotating a file helps if you know where the issue is to begin with. If you don&#8217;t even know what is breaking and there have been dozens or hundreds of commits since the last state where you know it worked, you will likely turn to <code>git bisect</code> to help you out. <code>bisect</code> does a binary search through your commit history to help you identify which commit introduced an issue as quickly as possible.</p>

<p>Let&#8217;s say you just pushed out a release of your code to a production environment and you&#8217;re getting bug reports about something that was not happening in your development environment and you can&#8217;t imagine why it&#8217;s doing that. You go back to your code and it turns out you can reproduce it, but you just can&#8217;t figure out what is going wrong. We can bisect it to find out. First we want to run <code>git bisect start</code> to get things going, then <code>git bisect bad</code> to tell the system that the current commit we are on is broken. Then we have to tell bisect when the last known good state was, so we run <code>git bisect good [good_commit]</code>.</p>

<pre><code>$ git bisect start
$ git bisect bad
$ git bisect good v1.0
Bisecting: 6 revisions left to test after this
[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo</code></pre>

<p>What Git did was figure out that there were about 12 commits in between where you are now and the broken commit, and it checked out the middle one for you. At this point you can run your test to see if the issue exists as of this commit. If it does, then it was introduced sometime before this, if it is not here then the issue was introduced sometime after it. It turns out that there is no issue here, so we tell Git that by typing <code>git bisect good</code> and continue on our journey.</p>

<pre><code>$ git bisect good
Bisecting: 3 revisions left to test after this
[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing</code></pre>

<p>Now we&#8217;re on another commit, halfway between the one we just tested and our bad commit. We run our test again and we find that this commit is broken, so we tell Git that with <code>git bisect bad</code>.</p>

<pre><code>$ git bisect bad
Bisecting: 1 revisions left to test after this
[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] drop exceptions table</code></pre>

<p>We find that this commit is fine, and now Git has all the information it needs to determine where the issue was introduced. It will tell us the SHA-1 of the first bad commit and show some of the commit information and which files were modified in that commit so we can figure out what happened that might have introduced this bug.</p>

<pre><code>$ git bisect good
b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit
commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04
Author: PJ Hyett &lt;pjhyett@example.com&gt;
Date:   Tue Jan 27 14:48:32 2009 -0800

    secure this thing

:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730 f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M	config</code></pre>

<p>When you are finished, you&#8217;ll want to run <code>git bisect reset</code> to reset your HEAD to where you were before you started this or else you&#8217;ll end up in a weird state.</p>

<pre><code>$ git bisect reset</code></pre>

<p>This is a really powerful tool that can help you check hundreds of commits for an introduced bug in minutes. In fact, if you have a script that will exit 0 if the project is good or non-0 if the project is bad, you can fully automate <code>git bisect</code>. First you again tell it the scope of the bisect by saying the known bad and good commits. You can do this by listing them with the <code>bisect start</code> command if you want, listing the known bad commit first and the known good commit second.</p>

<pre><code>$ git bisect start HEAD v1.0
$ git bisect run test-error.sh</code></pre>

<p>That will run <code>test-error.sh</code> on each checked out commit automatically until it finds the first broken commit. You can also run something like <code>make</code> or <code>make tests</code> or whatever you have that runs automated tests for you.</p>

<div id='nav'>
<a href='ch6-3.html'>prev</a> | <a href='ch6-5.html'>next</a>
</div>