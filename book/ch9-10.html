---
layout: master
title: Pro Git 9.10 Git Internals Transfer Protocols
---
<h2 id='transfer_protocols'>Transfer Protocols</h2>

<p>There are two major ways that Git can transfer data between two repositories - one is over HTTP and the other is via the so called &#8216;smart&#8217; protocols used in the file://, ssh:// and git:// transports. This section will quickly cover how these two main protocols operate.</p>

<h3 id='the_dumb_protocol'>The Dumb Protocol</h3>

<p>Git transport over HTTP is often referred to as the &#8216;dumb&#8217; protocol because it requires no Git-specific code on the server side during the transport process to work. The fetch process is simply a series of GET requests, where the client can assume the layout of the Git repository on the server. Let&#8217;s follow the http fetch process for our simplegit library.</p>

<pre><code>$ git clone http://github.com/schacon/simplegit-progit.git</code></pre>

<p>The first thing this command is going to do is pull down the &#8216;info/refs&#8217; file. This file is written by the <code>update-server-info</code> command, which is why you need to enable that as a post-recieve hook in order for the http transport to work properly.</p>

<pre><code>=&gt; GET info/refs
ca82a6dff817ec66f44342007202690a93763949	refs/heads/master</code></pre>

<p>So now we have a list of the remote references and SHAs. Next we&#8217;ll look for what the HEAD reference is so we know what to check out when we&#8217;re complete.</p>

<pre><code>=&gt; GET HEAD
ref: refs/heads/master</code></pre>

<p>We need to checkout the &#8216;master&#8217; branch when we&#8217;ve completed the process. Now we&#8217;re ready to start the walking process. Since our starting point is the <code>ca82a6</code> commit object we saw in the <code>info/refs</code> file, we&#8217;ll start by fetching that.</p>

<pre><code>=&gt; GET objects/ca/82a6dff817ec66f44342007202690a93763949
(179 bytes of binary data)</code></pre>

<p>So we got an object back - that object is in loose format on the server and we fetched it over a static HTTP GET request. Now we can Zlib uncompress it, strip off the header and look at the commit content, which looks like this:</p>

<pre><code>$ git cat-file -p ca82a6dff817ec66f44342007202690a93763949
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700

changed the verison number</code></pre>

<p>So now we have two more objects to retrieve - <code>cfda3b</code> which is the tree of content this points to, and <code>085bb3</code> which is the parent commit.</p>

<pre><code>=&gt; GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
(179 bytes of data)</code></pre>

<p>So that gives us our next commit object, let&#8217;s grab the tree object:</p>

<pre><code>=&gt; GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf
(404 - Not Found)</code></pre>

<p>Oops - it looks like that tree object is not in loose format on the server, we got a 404 response back. There are a couple of reasons for this - it could either be in an alternate repository, or it could be in a packfile in this repository. Git will check for any listed alternates first.</p>

<pre><code>=&gt; GET objects/info/http-alternates
(empty file)</code></pre>

<p>If this had come back with a list of alternate URLs, Git would then check for loose files and packfiles there - this is a nice mechanism for projects that are forks of one another to share objects on disk. However, since there are no listed alternates in this case, our object must be in a packfile. In order to see what packfiles are available on this server we need to get the <code>objects/info/packs</code> file which contains a listing of them (also generated by <code>update-server-info</code>).</p>

<pre><code>=&gt; GET objects/info/packs
P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack</code></pre>

<p>There is only one packfile on the server, so our object is pretty obviously in there, but we will check the index file to make sure. This is also useful if we had multiple packfiles on the server so we can see which packfile the object that we need is in.</p>

<pre><code>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx
(4k of binary data)</code></pre>

<p>Now that we have the packfile index, we can see if our object is in it - since the index basically just lists out the SHAs of the objects that are contained in the packfile and the offset to that object within it. Our object is there, so we&#8217;ll go ahead and get the whole packfile.</p>

<pre><code>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
(13k of binary data)</code></pre>

<p>Now we have our tree object so we continue walking our commits and they are all also within the packfile we just downloaded, so we don&#8217;t have to do any more requests to our server. Now Git will checkout a working copy of the &#8216;master&#8217; branch that was pointed to by the HEAD reference we downloaded at the beginning.</p>

<p>The entire output of this process looks like this:</p>

<pre><code>$ git clone http://github.com/schacon/simplegit-progit.git
Initialized empty Git repository in /private/tmp/simplegit-progit/.git/
got ca82a6dff817ec66f44342007202690a93763949
walk ca82a6dff817ec66f44342007202690a93763949
got 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Getting alternates list for http://github.com/schacon/simplegit-progit.git
Getting pack list for http://github.com/schacon/simplegit-progit.git
Getting index for pack 816a9b2334da9953e530f27bcac22082a9f5b835
Getting pack 816a9b2334da9953e530f27bcac22082a9f5b835
 which contains cfda3bf379e4f8dba8717dee55aab78aef7f4daf
walk 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
walk a11bef06a3f659402fe7563abf99ad00de2209e6</code></pre>

<h3 id='the_smart_protocol'>The Smart Protocol</h3>

<p>The HTTP method is simple, but a bit inefficient. A more common method of transferring data are the smart protocols. These are protocols that have a process on the remote end that is intelligent about Git - can read local data and figure out what the client has or needs and generate custom data for it. There are two sets of processes for transferring data - a pair for uploading data and a pair for downloading data.</p>

<h4 id='uploading_data'>Uploading Data</h4>

<p>To upload data to a remote process, Git uses the send-pack and receive-pack processes. The <code>send-pack</code> process runs on the client and connects to a <code>receive-pack</code> process on the remote side.</p>

<p>For example, say you run a <code>git push origin master</code> in your project. Git will fire up the <code>send-pack</code> process, which will initiate a connection over SSH to your server trying to run a command on the remote server via an SSH call that looks like this:</p>

<pre><code>$ ssh -x git@github.com &quot;git-receive-pack &#39;schacon/simplegit-progit.git&#39;&quot;
005bca82a6dff817ec66f44342007202690a93763949 refs/heads/master report-status delete-refs 
003e085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 refs/heads/topic
0000</code></pre>

<p>You can see that the <code>git-receive-pack</code> command will immediately respond with one line for each reference that it currently has, in this case just the master branch and its SHA. The first line will also have a list of capabilities that the server has (in this case &#8216;report-status&#8217; and &#8216;delete-refs&#8217;).</p>

<p>Each line starts with a four byte hex value specifying how long the rest of the line is. Our first line starts with &#8216;005b&#8217; which is &#8216;91&#8217; in hex, meaning that there are 91 bytes remaining on that line. The next line starts with &#8216;003e&#8217; which is &#8216;62&#8217;, so we read the remaining 62 bytes. The next line is &#8216;0000&#8217; meaning the server is done with it&#8217;s references listing.</p>

<p>Now that it knows what state the server is at, our <code>send-pack</code> process will determine what commits it has that the server does not. For each reference that this push is going to update, the <code>send-pack</code> process will tell the <code>receive-pack</code> process that. For instance, if we&#8217;re updating the &#8216;master&#8217; branch and adding an &#8216;experiment&#8217; branch, the <code>send-pack</code> response might look something like this:</p>

<pre><code>0085ca82a6dff817ec66f44342007202690a93763949 15027957951b64cf874c3557a0f3547bd83b3ff6 refs/heads/master report-status
00670000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d refs/heads/experiment
0000</code></pre>

<p>DWP: the sha of all 0s is for an added branch, I guess.</p>

<p>It will send a line for each reference we&#8217;re updating with the old SHA, the new SHA and the reference that is being updated. The first line will also have the capabilities that the client has. Next the client will upload a packfile of all the objects that the server does not have yet. Finally the server will respond with a success (or failure) indication.</p>

<pre><code>000Aunpack ok</code></pre>

<h4 id='downloading_data'>Downloading Data</h4>

<p>To download data, the <code>fetch-pack</code> and <code>upload-pack</code> processes are involved. The client will initiate a <code>fetch-pack</code> process which will connect to an <code>upload-pack</code> process on the remote side to negotiate what data will be transferred down.</p>

<p>There are different ways to initiate the upload-pack process on the remote repository. You can run via SSH in the same manner as the receive-pack process. It can also be initiated via the Git daemon - a process that listens on a server on port 9418 by default. The <code>fetch-pack</code> process will send data that looks like this to the daemon after connecting:</p>

<pre><code>003fgit-upload-pack schacon/simplegit-progit.git\000host=myserver.com\000</code></pre>

<p>It starts with the 4 bytes specifying how much data is following, then the command to run followed by a null byte, then the server&#8217;s hostname followed by a final null byte. The Git daemon will then check that the command can be run and that the repository exists and has public permissions. If everything is cool, it will fire up the <code>upload-pack</code> process and hand the request off to it.</p>

<p>If you are doing the fetch over SSH, <code>fetch-pack</code> will instead run something like this:</p>

<pre><code>$ ssh -x git@github.com &quot;git-upload-pack &#39;schacon/simplegit-progit.git&#39;&quot;</code></pre>

<p>In either case, once <code>fetch-pack</code> connects, <code>upload-pack</code> will send back something like this:</p>

<pre><code>0088ca82a6dff817ec66f44342007202690a93763949 HEAD\000multi_ack thin-pack side-band side-band-64k ofs-delta shallow no-progress include-tag
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
003e085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 refs/heads/topic
0000</code></pre>

<p>This is very similar to what <code>receive-pack</code> responds with but the capabilities will be different and it will send back the HEAD reference as well so that the client will know what to check out if this is a clone.</p>

<p>At this point the <code>fetch-pack</code> process will look at what objects it has and respond with the objects that it needs by sending &#8216;want&#8217; and then the SHA it wants. It will then send all the objects it already has with &#8216;have&#8217; then the SHA. At the end of this list it will write &#8216;done&#8217; to initiate the <code>upload-pack</code> process to start sending the packfile of the data it needs.</p>

<pre><code>0054want ca82a6dff817ec66f44342007202690a93763949 ofs-delta
0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
0000
0009done</code></pre>

<p>That is the very basic case of the transfer protocols - there are more complex cases when the client supports &#8216;multi_ack&#8217; or &#8216;side-band&#8217; capabilities but this is the basic back and forth that the smart protocol processes will do.</p>

<div id='nav'>
<a href='ch9-9.html'>prev</a> | <a href='ch9-11.html'>next</a>
</div>