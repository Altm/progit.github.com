## Maintaining a Project ##

In addition to knowing how to effectively contribute to a project, you will likely need to know how to maintain one as well.  This can consist of accepting and applying patches generated via `format-patch` and emailed to you, or by integrating changes in remote branches for repositories you have added as remotes to your project.  Whether you maintain a canonical repository or want to help by verifying or approving patches, you will need to know how to accept work in a way that is clearest for other contributors and is sustainable by you over the long run.

### Working in Topic Branches ###

It is generally a good idea to try out all new work you are thinking of integrating in a topic branch - a temporary branch specifically made to try out that new work.  This way it's easy to tweak patches individually and to be able to leave it there if it's not quite working out until you have time to come back to it. It is generally a good idea to create a simple branch name based on the theme of the work you're going to try, such as 'ruby\_client' or something similarly descriptive, so you can easily remember what it was if you have to abandon it for a while and come back to it later.  The maintainer of the Git project tends to namespace these branches as well, such as 'sc/ruby\_client' where 'sc' is short for the person who contributed the work.  As you'll remember, you can simply create the branch based off your master branch like this:

	$ git branch sc/ruby_client master
	
Or if you want to also switch to it immediately, you can use the 'checkout -b' option:

	$ git checkout -b sc/ruby_client master
	
Now we're ready to add our contributed work into this topic branch and determine if we want to merge it into our longer term branches.

### Applying Patches from Email ###

If you received a patch over email that you need to integrate into your project, you'll need to apply the patch in your topic branch to evaluate it.  There are two ways to apply an emailed patch.  

If you received the patch from someone who generated it with the `git diff` or simply a unix `diff` commands, you can apply it with the `git apply` command.  Assuming you saved the patch at `/tmp/patch-ruby-client.patch`, you can apply the patch like this:

	$ git apply /tmp/patch-ruby-client.patch

This will simply modify the files in your working directory.  It is almost identical to simply running a `patch -p1` command to apply the patch.  At this point, you will have to stage and commit the changes manually.

sop: Perhaps indicate why git apply is preferred over patch -p1, that is that git apply is more paranoid and accepts less fuzzy matches.  It also handles file adds/deletes/renames, if they are described by the git diff format, whereas patch does not handle these cases.  It also is an "apply all or abort all" model, where everything applies in one shot, or nothing at all is done to your work tree; vs. patch which can partially apply and reject others.  Really I think you should just emphasis that git apply is more paranoid than patch. {: class=note} 

If the contributor was a Git user and was good enough to use the `format-patch` command to generate their patch, then your job is hopefully a bit easier because the patch contains author information and a commit message for you. 

sop: Scratch "hopefully", it is easier to use git am.  Try to word this such that a new maintainer would get the idea that format-patch|am is the workflow to go with, and that apply is only for legacy diffs or some such thing.   {: class=note}

To apply a patch generated by `format-patch`, you use `git am`.  Now, technically, `git am` is built to read an mbox, so if someone has emailed you the patch properly using `git send-email` and you download that into an mbox format, then you can just point `git am` to that mbox and it will start applying all the patches it sees there.  However, if someone uploaded a patch file generated via `format-patch` to a ticketing system or something, then you can simply pass that file saved on your disk to `git am` to apply only it.

DWP: Are all of your readers going to know what an mbox looks like and how to get hold of one? Are you suggesting doing this direct from the mailbox for an account? If so, I'm assuming you want a seperate email account for receiving these commits. How does it cope with having done commits in an mbox already? Is there a way to point to somewhere in the middle? Have I missed the point completely? {: class=note}

	$ git am 0001-seeing-if-this-helps-the-gem.patch 
	Applying: seeing if this helps the gem

Now we can see that it applied cleanly and automatically created the new commit for us.

sop: Indicate the authorship information was taken from the email's From/Date headers.   {: class=note}

	$ git log -1
	commit f4ea86a0b4052d7d1241bcee52dca4a404bfd795
	Author: Scott Chacon <schacon@gmail.com>
	Date:   Fri Oct 24 09:53:59 2008 -0700

	    seeing if this helps the gem

sop: Be nice if this example used an author who is not Scott, and if you use --pretty=fuller to show both the author and committer attributions, so readers can get a better idea that the am attribution is automatically off the email. {: class=note}

It is possible, however, that it won't apply cleanly.  Perhaps your main branch has diverged too far from what the patch was built from or the patch depends on another patch you haven't applied yet.  In that case, the `git am` process will fail and ask you what you want to do.

	$ git am 0001-seeing-if-this-helps-the-gem.patch 
	Applying: seeing if this helps the gem
	error: patch failed: ticgit.gemspec:1
	error: ticgit.gemspec: patch does not apply
	Patch failed at 0001.
	When you have resolved this problem run "git am --resolved".
	If you would prefer to skip this patch, instead run "git am --skip".
	To restore the original branch and stop patching run "git am --abort".

This will put conflict markers in any files it has issues with, much like a conflicted merge or rebase operation.  You solve this much the same way - edit the file to resolve the conflict, stage the new file and then run `git am --resolved` to continue to the next patch.

	$ (fix the file)
	$ git add ticgit.gemspec 
	$ git am --resolved
	Applying: seeing if this helps the gem

If you want Git to try a bit more intelligently to resolve the conflict, you can pass a `-3` option to it, which will only work if the patch was generated with a version of Git that stores the SHA-1 values of the original blobs that were modified.  In this case, Git will try a more intelligent 3-way merge to resolve the conflict.

sop: Scratch the part about "was generated with a version of Git".  Pretty much any Git is going to do this now; if it doesn't its so ancient that its probably like pre-1.0 and the user should get a clue and upgrade to a post-1.5.  Why -3 fails often is the preimage SHA-1 isn't in this repository, because the ancestor revision was some private patch the author hasn't published, or published but the maintainer isn't bringing into their repository.  I find this often in git-gui, I don't have the preimage's necessary to use am -3 on many patches.  That's why -3 isn't on by default.   {: class=note}

	$ git am -3 0001-seeing-if-this-helps-the-gem.patch 
	Applying: seeing if this helps the gem
	error: patch failed: ticgit.gemspec:1
	error: ticgit.gemspec: patch does not apply
	Using index info to reconstruct a base tree...
	Falling back to patching base and 3-way merge...
	No changes -- Patch already applied.

In this case I can see that I was trying to apply a patch I had already applied - without the `-3` option, it simply looks like a conflict.  

If you are applying a number of patches from an mbox, you can also run the `am` command in interactive mode, which will stop at each patch that it finds and ask you if you want to apply it or not.

	$ git am -3 -i mbox
	Commit Body is:
	--------------------------
	seeing if this helps the gem
	--------------------------
	Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all 

This is nice if you have a number of patches saved there because you can view the patch first if you don't remember what it is, or not apply the patch if you have already done so.

Once all of the patches for your topic are applied and committed into your branch, you can then choose if and how to integrate them into a longer running branch.

If you want to see if a patch applies cleanly before you try, you can run `git apply --check` with the patch.

	$ git apply --check 0001-seeing-if-this-helps-the-gem.patch 
	error: patch failed: ticgit.gemspec:1
	error: ticgit.gemspec: patch does not apply

If there is no output, then it should apply cleanly. This will also exit with a non-zero status if the check fails, so you can use it in scripts if you want.

sop: Move this part to be with the git apply section, not with the git am section. {: class=note}

### Checking out Remote Branches ###

If your contribution came from a Git user that setup her own repository and pushed a number of changes into that and then sent you the URL to the repository and the name of the remote branch that the changes are in, then you can simply add them as a remote and do merges locally. 

For instance, if Jessica sends you an email saying that she has a great new feature in the 'ruby-client' branch of her repository, you can test it out by adding the remote and checking out that branch locally.

	$ git remote add jessica git://github.com/jessica/myproject.git
	$ git fetch jessica
	$ git checkout -b rubyclient jessica/ruby-client

Then if she emails you again later with another branch with another great feature in it, you can simply fetch and checkout since you already have the remote setup.

This is most useful if you are working with this person consistently.  If someone only has a single patch to contribute every once in a while, then accepting it over email might be less time consuming then requiring everyone to be running their own server and then having to continually be adding and removing remotes just to get a few patches.  You also are unlikely to want to have hundreds of remotes, each for someone who only contributed a patch or two.  However, scripts and hosted services may make this easier - it depends largely on how you develop and how your contributors develop.  

sop: Introduce git pull briefly as a way to perform one-shot pulls from users? {: class=note}

The other advantage of this is that you get the history of the commits as well, so although you may have legitimate merge issues, you know where in your history they based their work off of, so a proper 3-way merge is the default rather than having to supply a `-3` and hoping the diff client recorded the neccesary information.

sop: Again, the -3 in am is about you having the preimage, not the diff producer.  So the last sentence is wrong.  You can do a normal 3-way merge here because you have the merge base, and the merge base is explicitly recorded in the history. {: class=note}

### Determining What is Introduced ###

So now you should have a topic branch that has contributed work in it.  At this point you can determine what you would like to do with it.  Let's revisit a couple of commands and see how we can use them to review exactly what we would be introducing if we were to merge this into our main branch.

One thing that is often helpful is to just get a review of all the commits that are in this branch that are not in our `master` branch.  Git provides a shorthand way of determining this, which is the double-dot operator.  If you put two periods on the end of a branch name with the `git log` command, then it will limit the output to only commits that exist in the current branch you are on that are not reachable on the 'master' branch.   If our contributor had sent us two patches, we might see something like this:

sop: This is an awkward sentence to parse.  As a reader I had to read it 3 times before I grasped what you were saying, and I know Git.  I'm not sure how to put this better though as I understand you are trying to defer more on revision selection until later in the book.  But as a reader of technical books I often dislike sections like this where I need to read it 3 or 4 times to get what the author is saying... it makes me feel stupid.   {: class=note}

sop: Maybe use the more complete form, like "git log jessica --not master" here and leave the shorthand notation until later?  Its perhaps easier to explain that we want to see "what is in jessica's branch, but not yet in our master branch".  Yea, users are going to be like "that's so long to type, but I understand it!".  Later we can teach them how to save keystrokes.   {: class=note}

DWP: Presumably with --not you could exclude a different branch, so this is more interesting than .. {: class=note}

	$ git log master..
	commit 5b6235bd297351589efc4d73316f0a68d484f118
	Author: Scott Chacon <schacon@gmail.com>
	Date:   Fri Oct 24 09:53:59 2008 -0700

	    seeing if this helps the gem

	commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
	Author: Scott Chacon <schacon@gmail.com>
	Date:   Mon Oct 22 19:38:36 2008 -0700

	    updated the gemspec to hopefully work better

This double-dot operator is called a revision selector.  In the next chapter, we'll learn more about revision selection and see why this strange syntax works. 

If you want to see what exact changes each of those are introducing, remember that you can pass the `-p` option to `git log` and it will append the diff introduced to each commit.

If you want to see a full diff of what would happen if you were to merge this topic branch with another branch, you may have to use another weird trick to get the correct results.  You may think to run this:

	$ git diff master
	
This will give you a diff, but it may very well be misleading.  If your master branch has moved forward since you created the topic branch from it, then you will get seemingly strange results from this.  This is because Git will directly compare the snapshots of the last commit of the topic branch you are on and the snapshot of the last commit on the 'master' branch.  That means that if, for example, you've added a line in a file on the master branch, a direct comparison of the snapshots will look like the topic branch is going to remove that line.

If 'master' is a direct desendant of your topic branch, this isn't a problem, but if the two histories diverged, the diff will look like you're adding all the new stuff in your topic branch and removing everything new to the 'master' branch.

DWP: Is that the right way round? or is your topic branch a descendent of master? {: class=note}

What you really want to see is just the stuff that was added to the topic branch - the work you're going to introduce if you merge this branch with 'master'.  The way to do that is to have Git compare the last commit on your topic branch with the first common ancestor it has with the 'master' branch.

Technically, you can do that by explicitly figuring out the common ancestor and then running your diff on that.

	$ git merge-base HEAD master
	36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
	$ git diff 36c7db 

sop: Use "git merge-base master jessica" here, because it leads better into the "diff master...jessica" later.   {: class=note}
	
However, that is not convenient, so Git provides you with another shorthand for doing that exact thing, the triple-dot syntax.  In the context of the 'diff' command, you can put three periods after another branch to do a diff between the last commit of the branch you're on and it's common ancestor with another branch.

	$ git diff master...

That command will only show you what work your current topic branch has introduced since it's common ancestor with 'master'.  That is a very useful syntax to remember.

sop: Use "master...jessica" here instead of assuming current branch.  We can later teach shorthand.  Or maybe just teach it here with one extra sentence to say "if you leave the branch name of either side, HEAD, aka the current branch, is assumed".  {: class=note}

### Integrating Contributed Work ###

Once all of your work in your topic branch is ready to be integrated into a more mainline branch, the question is how to do it.  Furthermore, what overall workflow do you want to use to maintain your project?  There are a number of choices you have, so we'll cover a few of them.

#### Merging Workflows ####

One simple workflow would be to simply merge it into your 'master' branch.  In this scenario, you have a 'master' branch that contains basically stable code.  When you have work in a topic branch that you have done or that someone has contributed and you have verified, you simply merge it into your 'master' branch and then delete the topic branch, then continue the process.
	
![Topic Branch - Before Merge](/images/ch5/maint01.png)

![Topic Branch - After Merge](/images/ch5/maint02.png)


That is probably the simplest workflow, but somewhat problematic if you're dealing with larger repositories or projects.  

If you have more developers or a larger project, you will probably want to have at least a two-phase merge cycle.  In this scenario, you have two long running branches, 'master' and 'develop', in which you determine 'master' is only updated when a very stable release is cut and all new code is integrated into the 'develop' branch.  Then you regularly push both of these branches to the public repository.  Each time you merge a new topic branch in, you merge it into 'develop', then when you tag a release you fast-forward 'master' to wherever the now stable 'develop' branch is.

![Topic Branch 2 - Before Merge](/images/ch5/maintB-01.png)

![Topic Branch 2 - After Merge](/images/ch5/maintB-02.png)

![Topic Branch 2 - After Release](/images/ch5/maintB-03.png)

This way when people clone your project's repository, they can either checkout 'master' to build the latest stable version and keep up to date on that easily, or they can checkout 'develop' which is the more cutting edge stuff.

You can also continue this concept, having an 'integrate' branch where all the work is merged together, then when the codebase on that branch is stable and passes tests, you merge it into a 'develop' branch and when that has proven itself stable for a while, you fast forward your 'master' branch forward.
	
#### Large Merging Workflows ####

The Git project itself actually has four long running branches, 'master', 'next' and 'pu' (proposed updates) for new work and 'maint' for maintainance backports.  When new work is introduced by contributors, they are collected into topic branches in the maintainer's repository in a manner similar to what we've covered.  At this point, the topics are evaluated based on if they are deemed safe and ready for consumption or if they need more work.  If they are pretty safe, they will be merged into 'next' and that branch will be pushed up so everyone can try them out all integrated together.  

![Git Workflow - Topic Branches](/images/ch5/maintGit-01.png)
	
If they still need some work, they will be merged into 'pu' instead.  Once it is determined that they are totally stable, the topics will be re-merged into 'master' and then 'next' will be rebuilt from the topics that were in 'next' but didn't graduate to 'master' yet.  This means that 'master' will almost always move forward, next will be rebased occasially and 'pu' will be rebased even more often.

![Git Workflow - Merged Topics](/images/ch5/maintGit-02.png)

sop: WTF is todo branch?  I think you mean to call that "pu"?  Junio's todo is his Meta repository, which doesn't have anything in common with git.git but is his tools for managing git.git and keeping track of the "What's new in..." messages.   Further pu always contains next, and the other topics are merged into it.  {: class=note}	 

sop: The arrows from C16, C17, C13, C14, C15 to their topics go the wrong direction. {: class=note}

dwp: Where are next and pu in maintGit-01.png? {: class=note}

When a topic branch has finally been merged into 'master', it will be removed from the repository. The Git project also has a 'maint' branch that is forked off from the last release to provide backported patches to in case of the need for a maintainance release.  Thus, when you clone the Git repository, you have four branches that you can checkout to evaluate the project in different stages of development depending on how cutting edge you want to be or how you would like to contribute and the maintainer has a very structured workflow to help him vet new contributions.

#### Rebasing and Cherry Picking Workflows ####

Other maintainers prefer to rebase or cherry-pick contributed work on top of their 'master' branch, rather than merging them in, to keep a mostly linear history.  Once you have your work in a topic branch and have determined that you want to integrate it, you simply move to that branch and run the `rebase` command to rebuild the changes on top of your current 'master' (or 'develop', etc) branch. If that works well, then you can fast-forward your master branch and you will end up with a nicely linear project history.

The other way to move introduced work from one branch to another is to cherry-pick it.  A 'cherry-pick' in Git is like a 'rebase' for a single commit.  It simply takes the patch that was introduced in a commit and tries to reapply it on the branch that you're currently on.  This is useful if you have a number of commits on a topic branch and you only want to integrate one of them, or if you only have one commit on a topic branch and you would prefer to cherry-pick it rather than run 'rebase'.	For example, if we have a project that looks like this

![Pre Cherry Pick](/images/ch5/cherryPick-01.png)

At this point if we want to pull commit 'e43a6' into our master branch, we can run

	$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf
	Finished one cherry-pick.
	[master]: created a0a41a9: "More friendly message when locking the index fails."
	 3 files changed, 17 insertions(+), 3 deletions(-)
	
This pulls the exact same change introduced in 'e43a6', but we get a new commit SHA-1 value, since the date applied is different.  Now our history looks like this:

![Post Cherry Pick](/images/ch5/cherryPick-02.png)

Now we can remove our topic branch and drop the commits we did not want to pull in.

sop: Maybe make a note that rebase is discussed more later in chapter X ?  {: class=note}

### Tagging your Releases ###

Once you have decided to cut a release, you are probably going to want to drop a tag so you can recreate that release at any point going forward.  You can create a new tag like we covered back in chapter two.  If you decide to sign the tag as the maintainer, the tagging may look something like this:

	$ git tag -s v1.5 -m 'my signed 1.5 tag'

	You need a passphrase to unlock the secret key for
	user: "Scott Chacon <schacon@gmail.com>"
	1024-bit DSA key, ID F721C45A, created 2009-02-09

Now if you do want to sign your tags, you may have the problem of distributing your public PGP key used to sign your tags.  The maintainer of the Git project has solved this by including his public key as a blob in the repository and then adding a tag that pointed directly to that content.  If you want to do this, you can figure out which key you want by running `gpg --list-keys`.

	$ gpg --list-keys
	/Users/schacon/.gnupg/pubring.gpg
	---------------------------------
	pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
	uid                  Scott Chacon <schacon@gmail.com>
	sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]

Then you can directly import the key into the Git database by exporting it and piping that through `git hash-object` which will write a new blob with those contents into Git and give you the SHA-1 of the blob back.
	
	$ gpg -a --export F721C45A | git hash-object -w --stdin
	659ef797d181633c87ec71ac3f9ba29fe5775b92

Now that you have the contents of your key in Git, you can create a tag that points directly to it by simply specifying the new SHA-1 value that the `hash-object` command gave you.

	$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92

Now if you run a `git push --tags` the 'maintainer-pgp-pub' tag will be shared with everyone.  If anyone wants to verify a tag, they can directly import your pgp key by pulling the blob directly out of the database and importing it into GPG.

	$ git show maintainer-pgp-pub | gpg --import

Now they can use that key to verify all your signed tags.  Also, if you include instructions in the tag message, than just running `git show <tag>` will let you give the end-user more specific instructions about tag verification.

### Generating a Build Number ###

Since Git doesn't have clean numbers like 'v1345' or something equivalent to go with each commit, if you want to have a human readable name to go with a commit, you can run `git describe` on that commit.  Git will give you the name of the nearest tag with the number of commits on top of that tag and a partial SHA-1 value of the commit you are describing.

sop: Change "clean numbers" to "monotonically increasing numbers" ?  {: class=note}

	$ git describe master
	v1.6.2-rc1-20-g8c5b85c

This way you can export a snapshot or build and name it something understandable to people.  In fact, if you build Git from source code cloned from the Git repository, `git --version` will give you something that looks like this.  If you are describing a commit that you have directly tagged, it will simply give you the tag name.

sop: Say something here about how git describe favors annotated tags (tags created with the -a or -s flag) and that release tags should therefore be tagged with one or the other option, to ensure git describe notices them.   {: class=note}

sop: Also say something about how you can (usually) do "git checkout outputofdescribe" to get back to that version, but that this relies upon the abbreviated SHA-1 and thus isn't stable for all time.  Maybe include a short thing about how the Linux kernel had abbreviations jump from 8 to 10 digits not too long ago, and that invalidated many of these older describe abbreviations.   {: class=note}

### Preparing a release ###

Now we want to release a build.  One of the things we're going to want to do is create an archive of the latest snapshot of our code for those poor souls who do not use Git.  The command to do this is `git archive`.

	$ git archive master --prefix='project/' | gzip > `git describe master`.tar.gz
	$ ls *.tar.gz
	v1.6.2-rc1-20-g8c5b85c.tar.gz

Now if someone opens that tarball, they will get the latest snapshot of your project under a 'project' directory.  You can also create a zip archive in much the same way, but by passing the `--format=zip` option to `git archive`.

	$ git archive master --prefix='project/' --format=zip > `git describe master`.zip

You now have a nice tarball and a zip archive of your project release that you can upload to your website or email to people.

### The Shortlog ###

Now it's time to email your mailing list of people that want to know what's happening in your project.  A nice way of quickly getting a sort of changelog of what has been added to your project since your last release or email is to use the `git shortlog` command.  This will nicely summarize all the commits in the range that you give it, so for example if you want to see a summary of all the commits since your last release, and your last release was named 'v1.0.1'

	$ git shortlog --no-merges v1.0.1..
	Chris Wanstrath (8):
	      Add support for annotated tags to Grit::Tag
	      Add packed-refs annotated tag support.
	      Add Grit::Commit#to_patch
	      Update version and History.txt
	      Remove stray `puts`
	      Make ls_tree ignore nils

	Tom Preston-Werner (4):
	      fix dates in history
	      dynamic version method
	      Version bump to 1.0.2
	      Regenerated gemspec for version 1.0.2

sop: Use "master --not v1.0.1" here I think, for same reason I said earlier.   {: class=note}

You can see that we get a nice clean summary of all the commits since 'v1.0.1', grouped by author, that we can email to our list.

### Summary ###

At this point, you should feel fairly comfortable contributing to a project in Git as well as maintaining your own project or otherwise integrating other users contributions.  Congratulations on being an effective Git developer!  In the next chapter, we'll learn some more powerful tools and tips for dealing with more complex situations that will truly make you a Git master.
